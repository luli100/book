# 单一职责原则（SRP）

单一职责原则曾经在 Tom Demaro 和 Meilir Page-Jones 的著作中描述过，并称之为内聚性。他们把内聚性定义为：一个模块的组成元素之间的功能相关性。在本文章中，我们稍微改变一下它的含义，把内聚性和引起一个模块或者类改变的作用力联系起来。

## 单一职责原则

就一个类而言，应该仅有一个引起它变化的原因

考虑第 6 章中保龄球比赛的例子。在开发它的大部分时间内，Game 类一直具有两个不同的职责。一个职责是跟踪当前轮的比赛，另一个职责是计算比赛的得分。最后，RCM和RSK把这两个职责分离到两个类中。Game类保持跟踪每一轮比赛的职责，Scorer类负责计算比赛的得分。

为何要把这两个职责分离到单独的类中呢？因为每一个职责都是一个变化轴线。当需要变化时，该变化会反映为类的职责变化。如果一个类承担了多于一个职责，那么引起它变化的原因就会有多个。

如果一个类承担的职责过多，就等于把这些职责耦合在了一起。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。

例如，考虑图 1 中的设计。Rectangle 类具有两个方法，如果所示。一个方法把矩形绘制在屏幕上，另一个方法计算矩形的面积。

有两个不同的应用程序使用 Rectangle 类。一个应用程序是有关计算几何学方面的，使用 Rectangle 类来处理几何形状的数据运算，但它从来不会在屏幕上绘制矩形。另一个应用程序实质上有关图形绘制方面的，它也可能会进行一些几何运算，但它可能会在屏幕上绘制矩形。

这个设计违反了单一职责原则。Rectangle 类具有两个职责。第一个职责提供了一个矩形几何形状的数学运算模型；第二个职责是在 GUI 上渲染矩形。

对于SRP的违反导致了一些严重问题。首先，我们必须在计算几何应用程序中包含进 GUI 代码。如果