## 第一章 调试工具简介

我曾看到过许多开发人员使用错误的工具来分析问题，更有甚者，有些人连任何工具都不使用。他们采取的分析方法通常包括：输出更多的调试信息，或者做一些临时性的代码审查（code review）。这里的临时性是指，通过猜测来推断问题可能来自哪部分代码。例如，如果在系统的事务服务中出现了一个错误，那么他们可能会对整个事务引擎的代码进行审查而问题实际上来自事务引擎之外的代码。有时候，开发人员会幸运地发现问题刚好处于他们正在审查的代码中。然而，在更多情况下并非如此，问题发生的位置和表现出来的位置往往相去甚远。通过使用一些功能强大的调试工具，开发人员可以极大地减少在分析问题时耗费地时间。

在分析 .NET 应用程序的问题时，有些工具可以使分析过程变得更为有效。其中，一部分工具侧重于分析某一类特定的问题，而其他工具则可以同时处理若干类问题。我们要知道每种工具在哪些情况下使用以及如何使用，这一点非常重要。本章将简要介绍在本书中使用的各种工具，包括每种工具的不同特性，适用于哪些类型的问题，从何处下载，如何安装，以及运行该工具的一些示例等。值得注意的使，这里介绍的所有工具都是免费下载的。

### 1.1 Windows 调试工具集

|   应用场合    |   一组调试器和调试工具    |
|   :---:       |   :---:   |
|   版本        |   6.8.4.0 |
|   下载地址    |   http://www.microsoft.com/whdc/devtools/debugging/default.mspx   |

Windows 调试工具集是一个免费的软件包，它包含了一组功能强大的调试器和调试工具，用来帮助分析软件中的各种问题。软件包分为两个版本：32 位版和 64 位版，具体使用哪个版本要取决于调试任务所在的架构。在本书中，所有的调试任务都将使用 32 位的版本。

在 Windows 调试工具集中共包括三种用户态调试器——NTSD、CDB 和 WinDbg，以及一种内核态调试器（kd）。虽然这三种调试器彼此使相互独立的，但重要的是要知道它们都依赖于相同的内核调试器引擎。在这些调试器之间的主要差异是，WindDbg 有一个图形用户界面（GUI），这使得它在进行源代码级调试（Source Level Debugging）时用起来更为容易。而与之不同的是，NTSD 和 CDB 都只是基于控制台的调试器。本书给出的调试器会话截图都是通过 NTSD 来截取的。

在选择了合适的调试器（32 位或者 64 位）后，Windows 调试工具集的安装过程很简单，只需要选择默认的安装选项就可以了。默认的安装路径是

**%programfiles%\Debugging Tools for Windows**

在编写本书时，Windows 调试工具集的最新版本为 6.8.4.0。因此，在读者拿到本书的时候，很可能会发布一个更新的版本。即便如此，调试器的输出信息并不会发生太大变动，而本书中介绍的内容也同样适用。在调试器的下载站点上还保留了之前（2~3个）版本调试器的下载地址。如果希望使用本书中用到的版本，那么可以下载版本号为 6.8.4.0 的 Windows 调试工具集。

### 1.2 .NET2.0 可再发行组件

|   应用场合    |   .NET 运行时(.NET Runtime)   |
|   :----:      |   :---:   |
|   版本        |   2.0 |
|   下载地址    |   自己去找    |

## 第 2 章 CLR 基础

无论采取什么形式来分析问题，对被调试系统的底层了解得越多，就越有可能成功地找出问题根源。在 .NET 领域，这个原则同样适用，即我们需要理解运行时本身的各种功能和行为。了解垃圾收集器的工作原理将使你在调试内存泄漏问题时更加高效。了解互用性的工作原理将使你在调试 COM 问题时更加高效，而了解同步机制的工作原理将使你在调试挂起问题时更为高效，诸如此类大的观点不胜枚举。通过应用程序深入到运行时的内部，将极大地提高调试的成功概率。在传统调试方式中需要数星期才能解决的问题，现在或许在很短的时间内就可以解决。

在本章中将要简要介绍 .NET 运行时。我们会讨论一些在调试 .NET 应用程序中非常有用的核心运行时组件及概念，并将通过一些调试器和工具来说明运行时的内部机制。但是，本章并不会对 .NET 运行时进行详尽介绍，而只是侧重于介绍一些给开发人员造成问题的常见领域。

### 2.1 高层概览

从高层面来看，.NET 是一个虚拟的运行时环境，它包含了一个虚拟执行引擎——通用语言运行时（Common Language Runtime，CLR）以及一组相关的框架库。基于 .NET 编写的应用程序在编译时并不会转换为机器代码，而是转换为一种中间语言代码；在实际执行时，执行引擎将（根据不同的架构）把这种代码转换为机器代码。尽管这使得 CLR 看上去像一个解释器（解释中间语言），但在 CLR 和解析器之间存在一个本质差异，即 CLR 不会每次都对中间语言执行转换操作。CLR 每次都将一部分中间语言代码转换为机器代码，然后在随后的执行中反复使用这段被转换的机器代码。虚拟执行引擎给开发人员带来了一些非常关键的好处，包括：

* 内存管理
* 安全管理
* 代码验证

为了更好的理解 .NET 由哪些组件构成，图 2-1 给出了在 .NET 中包含的各种不同组件。


