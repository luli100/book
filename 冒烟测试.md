在程序设计和软件测试领域，冒烟测试（也包括信心测试、健全性测试、构建验证测试（BVT）、构建验收测试）是指初步地进行测试，并以此展示一些简单但足以影响发布软件版本的这一高级别的错误。冒烟测试是测试用例的子集，测试主要为了覆盖了组件或系统的最重要功能，并用于辅助评价一个软件的主要功能是否正常运行。当使用冒烟测试判断一个程序是否需要更深层次的、颗粒度更为细小的测试时，该测试也被称为入门测试（intake test）。或者，在测试部门对新版本程序进行测试之前，冒烟测试用于自动化测试新版本是否可以正常运行，是否值得测试。在DevOps范例中，使用BVT步骤是持续集成成熟阶段的标志之一。

例如，冒烟测试可能会解决一些基本问题，例如“程序是否运行？”，“用户界面是否打开？”或“单击事件是否有效？”等。冒烟测试的目的在于确认程序是否严重到，需要立即测试非必须的测试。如《Lessons Learned in Software Testing》所写，“冒烟测试仅仅是在短时间广泛地覆盖产品功能。如果关键功能无法正常工作或关键bug尚未修复，那么你们的团队就不需要浪费更多时间去安装部署以及测试。则烟雾测试将在有限的时间内广泛涵盖产品功能，不会浪费更多的时间来安装或测试”。

冒烟测试通常会快速地进行，好处就是反馈也是很快，相比之下，更为全面地套件测试通常会花费更长的时间。

每日构建和冒烟测试是工业界公认的最佳实践之一。测试人员在构建并更深一步的测试之前，有必要进行冒烟测试。微软声称，“在代码进行审查之后，冒烟测试是识别并修复软件的性价比最高的方法”。

冒烟测试，可以是手动测试或自动工具进行冒烟测试。对于自动化工具测试，构建工程的程序通常会顺带进行该测试。

冒烟测试可以是功能测试或者单元测试。功能测试通常会使用各种输入设备。从而执行完整的程序。单元测试则是针对单一功能、子例程、对象的方法。功能测试可以是脚本化的输入，也可以是自动化的鼠标事件。单元测试可以是实现代码内部独立功能，也可以是通过调用的方式进行测试。

**误区一：开发不知道冒烟测试是干嘛的**

通常一提到冒烟测试，大家都习惯性的把关注点放在后面两个字：测试。开发的同学一听这个活动，很开心，这不是我们的活儿，应该是测试人员来完成的。真的是这样么？

冒烟测试这个名称的来历，最初是从电路板测试得来的。因为当电路板做好以后，首先会加点测试，如果板子没有冒烟再进行其它测试，否则就必须重新来过。

而在软件研发中，冒烟测试其实是微软首先提出来的一个概念，和微软一只提倡的每日 build（构建版本）有很密切的联系。具体说，冒烟测试就是在每日 build 建立后，对系统的基本功能进行简单的测试。这种测试强调程序的主要功能进行验证，而不会对具体功能进行更深入的测试。

冒烟只是这类活动更形象化一些的叫法，直接叫做 BVT（Build Verification Testing），可能更为贴切。

**误区二：冒烟测试为一个测试阶段**

有些团队在定制流程时会有一个阶段叫冒烟测试，但是就算不通过也会继续做后面其它部分的测试。就像平时进机场的时候机场口会有个小哥哥或者小姐姐拿一个不知名的物体对你扫一下，大多数情况下旅客们都是面无表情的走过他们身边，扫就扫呗，又不少两斤肉。

实际上什么打火机，充电宝啊，会在之后的安检过程才会被一一挑出来。

我们反过头来看当时微软提出来这个概念，它的重点其实在于 daily build，也就是说冒烟测试是随着每一次构建而走的，它应该是一个开关而不是一个研发流程中的测试阶段。

过，你可以继续后面的测试。不过，直接返工等待下一次的构建。这才是冒烟测试应有的态度。

**误区三：冒烟测试需要把此次需求的主流程都走一遍**

一些团队通常为了督促开发人员提高研发质量而把冒烟测试通过率作为一个衡量指标。这种出发点是极好的，实现手段上经常会有一点点小偏差。

冒烟测试主要是测试系统的主流程是否可用，如果这次的需求不涉及到太多主流程上面的更改，那真的有必要把这些案例都加入到冒烟测试中么？

最后，冒烟测试的最佳实践还是最好被自动化，在 CI 中每一个 build 都自动化的去执行主流程的测试，确保其是一个基本可用的版本。手动测试这事儿吧，西部世界都第二季完结了，你们还没醒悟么？

**现在我终于明白了，你从最初就一直想要的东西——去面对自己，以及我必须变成的人。**

