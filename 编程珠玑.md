- [第1部分 预备知识](#第1部分-预备知识)
  - [第1章 开篇](#第1章-开篇)
    - [1.1一次友好的对话](#11一次友好的对话)
    - [1.2精确的问题陈述](#12精确的问题陈述)
    - [1.3程序设计](#13程序设计)
    - [1.4实现纲要](#14实现纲要)
    - [1.5原则](#15原则)
    - [1.6问题](#16问题)
    - [1.7进阶阅读](#17进阶阅读)
  - [第2章啊哈！算法](#第2章啊哈算法)
    - [2.1三个问题](#21三个问题)
    - [2.2无所不在的二分查找法](#22无所不在的二分查找法)
    - [2.3原语的力量](#23原语的力量)
    - [2.4归拢：排序](#24归拢排序)
    - [2.5原则](#25原则)
    - [2.6问题](#26问题)
    - [2.7进阶阅读](#27进阶阅读)
    - [2.8实现变位词程序[补充材料]](#28实现变位词程序补充材料)
  - [第3章数据结构程序](#第3章数据结构程序)
    - [3.1调查程序](#31调查程序)
  - [第4章编写正确的程序](#第4章编写正确的程序)
    - [4.1 二分查找的挑战](#41-二分查找的挑战)
  - [第5章编程中的次要问题](#第5章编程中的次要问题)

# 第1部分 预备知识

这5章首先回顾了编程基础。第1章介绍了单个问题的历史。谨慎的问题定义与直接的编程技巧相结合，造就了一流的解决方案。该章说明了本书的中心主题：认真思考分析真实的案例时一件有趣的事，并且很可能在实践中获得收益。

第2章考察了三个问题，强调了算法上的理解如何才能产生简单而有效的代码。第3章概述了数据结构在软件设计中所起的关键作用。

第4章将程序验证作为编写正确代码的一款工具引入。在第9章、第11章以及第14章中，当我们派生出更复杂（而且更快捷）的函数时，验证技术将得到广泛使用。

第5章向大家展示了我们是如何在实际代码中实现那些抽象程序的：我们使用脚手架来检测某个函数，使用测试例子来验证函数，以及度量其性能。

## 第1章 开篇

程序员提出的问题很简单：“我该如何对磁盘文件进行排序？”在我向大家述说我回答这个问题时所犯的第一次错误情形之前，我先给大家一次比我做得更好的机会。你会怎么回答这个问题呢？

### 1.1一次友好的对话

我犯的错误就是回答了程序员的问题。我向他简略地介绍了一下如何在磁盘中实现合并排序（Merge Sort）之后，我建议他先专研一下算法课本，但这并不能满足他地热情。实际上他更关心地还是怎样解决该问题，而不是进一步学习。后来我给他讲述了流行编程书籍中的磁盘排序程序。该程序包括大约有10多个函数，200行程序代码；我估计实现和测试这些代码最多花费程序员一个星期的时间。

我想我已经解决了他的问题，但是他的犹豫导致我走了回头路。我们之间的对话如下所示，我的问题用斜体字表示。

为什么你老师希望编写自己的排序程序？为什么不使用系统提供的排序程序呢？

我需要在一个大型系统中进行排序，但由于技术不明朗的原因，我不能使用系统文件排序程序。

需要排序的内容究竟是什么？文件中有多少记录？每个记录的格式是什么？

该文件包含至多10000000个记录，每条记录都是一个7位整数。

等一下。假如文件那么小的话，为什么还要费力地使用磁盘排序呢？为什么不在主存储器中对它进行排序呢？

尽管机器有很多MB的主存储器，但是该排序功能属于某个大型系统中的一部分。我想实际上我可能只有1MB的空闲内存。

你能将有关记录方面的内容说得更详细一点吗？

每个记录都是一个7位正整数，并且没有其他的关联数据，每个整数至多只能出现一次。

通过对话，问题描述得更清晰了。在美国，电话号码由3位区号与7位其他号码组成。拨打包含免费区号800的电话是不收费的（当时这是唯一一类免费号码）。实际的免费电话号码数据库包含由大量的信息，包括免费电话号码、拨打的实际号码（有时有几个号码，还有号码拨打区域以及时间方面的规定）、用户名称和地址，等等。

程序员正在建立一个小小的系统角落来处理这一类数据库，将要进行排序的整数就是那些免费电话号码。输入文件是一个号码列表（其他信息全被删除了），并且同一号码出现两次以上将是一个错误。预期的输出是一个包含大量号码，并且以升序的方式进行排序的文件。实际环境同时也定义了性能需求。在与系统进行长时间的会话期间，用户请求排序文件的频率大约是每小时一次。在完成排序之前，用户不能做任何事情。因此排序时间不能太长，最合适的运行时间是 10 秒钟。

### 1.2精确的问题陈述

对于程序员来说，这些需求综合起来就是说：“如何进行磁盘文件排序？”在着手解决这个问题之前，让我们不带偏见地以更有用的形式进行需求分析：

**输入：**
所输入的是一个文件，至多包含n个正整数，每个正整数都是7位。如果输入时某一个整数出现了两次，就会产生一个致命的错误。这些正整数与其他任何数据都不关联。

**输出：**
以增序形式输出经过排序的整数列表。

**约束：**
至多（大概）只有1MB的可用主存；但是可用磁盘空间非常充足。运行时间之说只允许几分钟；10秒钟是最适宜的运行时间。

请花片刻时间思考一下这个问题的规格说明。现在你会给程序员一点什么建议呢？

### 1.3程序设计

显而易见，该程序使用普通的基于磁盘的合并排序作为起始点，但是对它进行了调整，以反映出我们将要排序整数这一事实。那样一来就将原来的200行代码减少了几十行，同时使代码的执行速度更快乐。它大概仍然需要几天的时间使代码调试通过并运行起来。

第二个解决方案甚至更加利用了这个排序问题的特定本性。如果将每个号码存储在7个字节里，那么我们就能够在可用的1M空间中存储大约 143000个号码。可是如果我们将每个号码表示成32位整数的话，我们就可以在1MB空间钟存储250000个号码。因此，我们将使用一个在输入文件钟带有40个通道的程序。在第一个通道中它将0到249999之间的任意整数读取到内存中，并（至多）对250000个整数进行排序，一次类推，直到第40个通道，它将排序9750000到9999999之间的整数。 快速排序（QuickSort）在主存中相当有效，它只需要20行代码（我们将在第11章中看到这一点）。因此整个程序只需1到2页的代码即可实现，并且该程序还有一个令人满意的特性，即我们不必担心使用中间磁盘文件的问题。但是不幸的是，为了完成这个程序，我们付出了读取整个输入文件40次的代价。

合并排序程序从输入中一次性读取文件，然后在工作文件的辅助下进行排序（注意工作文件会进行多次读取与写入操作），之后再对文件进行一次性写入操作。

40个通道的算法不使用中间文件，需要多次读取输入文件，但只进行一次输出文件的写入操作。
我们可能更愿意采用下面所示的方案。这个方案结合了前两个方案各自的优势。它对输入只进行一次操作，并且不使用中间文件。

只有将输入文件中的所有整数都表示再可用的主存空间中时，我们才能这么做。这样该问题就归结为我们是否可以将至多一千万个不同整数表示在大约八百万可用的比特中。请根据自己的情况选择一种合适的方法。

### 1.4实现纲要

我们考察的只是简单问题，在现实中，位图和位向量很常见，它们的表示方法会更加让我们惊讶。我们可以使用一个20位的字符串来表示一个小型的小于20的非负整数集合。例如，我们可以将集合{1，2，3，5，8，13}存储在下面这个字符串中：

0 1 1 1 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 0

集合中代表数字的各个位设置位1，而其他的位全部都设为0。

在现实问题中，每个整数的7个十进制数字表示了一个小于千万的数字。我们将使用一个具有一千万位的字符串表示该文件，在该字符串中，当且仅当整数i在该文件中时，第i个位才打开（设为1）。（程序员发现有200万个空闲的位；问题5仔细研究了严格限制在1MB空间时所出现的问题。）这种表示法使用了这个问题（该问题在排序问题中不太常见）中的三个属性；输入的范围相对要小一些，并且还不包含重复数据，而且没有数据与单个整数以外的每一记录相关联。

### 1.5原则
### 1.6问题
### 1.7进阶阅读

## 第2章啊哈！算法

研究算法对于正在工作的程序员来说时很有用的。有关该主题的课程将使学员掌握重要任务的功能以及解决新问题的技术。在后面的章节中我们将看到高级算法工具有时候会如何度i软件系统产生重要的影响，它不仅减少了开发时间，而且加快了执行速度。

算法和那些复杂的思想一样非常关键，对于比较普通级别的编程来说它起着重要的作用。在马丁•加德纳所著的《Aha!Insight（啊哈！灵机一动）》（我就是将这个书名窃用为本章标题的）一书中，他描述了和我一致的观点：“看起来很困难的问题解决起来可能很简单，并且还很可能出人意料之外。”与某些高级方法不一样的是，只有经过广泛的研究之后才能对算法具备那种出神入化的理解力。任何愿意在编码前、编码期间以及编码后认真思考的程序员都可具备这种能力。

### 2.1三个问题

为一般起见，本章将围绕三个问题进行展开，在继续阅读之前请尝试回答这些问题。

A.给定一个包含32位整数的顺序文件，它至多只能包含40亿个这样的整数，并且整数的次序是随机的。请查找一个此文件中不存在的32位整数（至少必有一个遗漏，为什么？）。在有足够主存的情况下，你会如何解决这个问题？如果你可以使用若干外部临时文件但可用主存却只有上百字节，你会如何解决这个问题呢？

B.请将一个具有n个元素的一维向量向左旋转i个位置。例如，假设n=8，i=3，那么向量abcdefgh旋转之后得到向量defghabc。简单编码使用一个具有n个元素的中间向量分n步即可完成此作业。你可以仅使用几时字节的微小内存，花费与n成比例的时间来旋转该向量吗？

C.给定一本英语单词词典，请找到所有的变位词集。例如，因为“pots”、“stop”、“tops”相互之间都是由另一个词的各个字母改变序列而构成的，因此这些词相互之间就是变位词。

### 2.2无所不在的二分查找法
### 2.3原语的力量
### 2.4归拢：排序
### 2.5原则
### 2.6问题
### 2.7进阶阅读
### 2.8实现变位词程序[补充材料]

## 第3章数据结构程序

大多数程序员都看过数据结构程序，而大多数好的程序员都意识到自己起码编写过一个数据结构程序。这些数据结构程序本该短小、干净、漂亮，而它们实际确实那种巨大的、混乱的、丑陋不堪的程序。我曾经见过几个程序，它们可以归结为类似以下所示代码：
```
if(k==1) c001++
if(k==2)c002++
...
if(k==500)c500++
```

尽管程序实际所完成的任务要稍微更复杂一些，但是不会将它们误认为是要对1到500之间的每一个整数在文件中出现的次数进行计数。每个程序所包含的代码都超过1000行。今天大多数程序员马上都会意识到，如果使用另一个不同的数据结构（一个具有500个元素的数组）来代替500个单独的变量，那么使用一个只有原来程序零头大小的程序就可以完成该任务。

因此，本章标题的含义就是：合适的数据视图确实构造了程序。本章描述了各种不同的程序，通过重构它们的内部数据，使其变得更加简短（而且更好）。

### 3.1调查程序

我们将要研究的下一个程序总结了由某一特定大学的学生所填写的两万份问卷。部分输出结果如下所示：

|                   |   Total |  US City|Perm Visa|Perm Visa| Male | Female |
|   :---            |   :---: |   :---: | :---: |   :---: |   :---:   | :---:  |
| African American  |   1289  |   1239  |   17  |   2	  |   684	  |   593  |
| Mexican American  |   675   |   577	|   80  |   11    |   448	  |   219  |
| Native American   |   198   |   182	|   5	|   3	  |   132	  |   64   |
| Spanish Surname	|   411   |   223	|   152 |   20    |   224	  |   179  |
| Asian American    |   519   |   312	|   152 |   41    |   247	  |   270  |
| Caucasian         |   16272 |   15663 |   355 |   33    |   9367    |   6836 |
| Other             |   225   |   123	|   78  |   19    |   129	  |   92   |
| Totals            |   19589 |   18319 |   839 |   129   |   11231   |   8253 |


对于某一种群而言，男性数目与女性数目之和要稍稍小于总数，因为有些人没有回答某些问题。实际的输出更加复杂。我希纳是了所有7行以及总计行，但只显示了6列，表示总计和两个其他的类别，即国籍和性别。在实际的问题中，共25列，表示8个类别以及三个类似的输出页面：其中两个页面各自用于两个独立的校园；另一个页面用于那两个页面的总和。还有其他少数关系密切的将要输出的表。

## 第4章编写正确的程序

在20世纪60年代后期，人们一直都在谈论验证其他程序正确性的程序的前途问题。不幸的是，在中间的几十年间，很少出现异议，谈论来谈论去还是自动化验证系统的问题。然而，尽管是不能实现的想法，有关程序验证方面的研究还是给我们提供了一些有价值的东西，这些东西远远不只是一个将程序囫囵吞下然后闪现“好”或者“坏”的黑箱子——现在我们对计算机编程已有一个基本的理解了。

本章的目的在于向你展示这种基本理解如何可以帮助现实中的程序员编写正确的程序。一位读者这样特征化地描述了大多数程序员成长时所伴随地软件编程方法：“编写代码，然后将它抛过墙去，让QA（质量保证）或QT（质量测试）去处理bug问题”。本章描述了一个可选的方法。在开始着手这个主题以前，我们必须正确地记住它。编码技能只构成编写正确程序的一小部分。大部分任务是前面三章中的主题：问题定义、算法设计以及数据结构选择。如果那些任务你都完成得比较出色，那么编写正确的代码一般来说也就比较轻松了。

### 4.1 二分查找的挑战

即使有了最优秀的设计，程序员常常还必须编写精细的代码。本章就是关于一个要求特别小心编码的问题：二分查找。在分析完该问题并勾画出算法之后，我们将使用验证原则编写程序。

## 第5章编程中的次要问题


