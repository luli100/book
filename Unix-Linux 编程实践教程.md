
- [第5章 连接控制：学习tty](#第5章-连接控制学习tty)
  - [5.1 为设备编程](#51-为设备编程)
  - [5.2 设备就像文件](#52-设备就像文件)
  - [5.4 磁盘连接的属性](#54-磁盘连接的属性)
    - [属性1: 缓冲](#属性1-缓冲)
    - [属性2：自动添加模式](#属性2自动添加模式)
    - [用open控制文件描述符](#用open控制文件描述符)
    - [磁盘连接小结](#磁盘连接小结)
  - [5.5终端连接的属性](#55终端连接的属性)
    - [终端的I/O并不如此简单](#终端的io并不如此简单)
    - [终端驱动程序](#终端驱动程序)
    - [stty命令](#stty命令)
    - [编写终端驱动程序：关于设置](#编写终端驱动程序关于设置)
    - [编写终端驱动程序：关于函数](#编写终端驱动程序关于函数)
    - [终端连接小结](#终端连接小结)
  - [5.6 其他设备编程：ioctl](#56-其他设备编程ioctl)
  - [5.7 文件、设备和流](#57-文件设备和流)
- [第6章 为用户编程：终端控制和信号](#第6章-为用户编程终端控制和信号)
  - [6.1软件工具与针对特定设备编写的程序](#61软件工具与针对特定设备编写的程序)
  - [6.2终端驱动程序的模式](#62终端驱动程序的模式)
  - [6.3编写一个用户程序：play_again.c](#63编写一个用户程序play_againc)
  - [6.4信号](#64信号)

# 第5章 连接控制：学习tty

## 5.1 为设备编程

前面章节中已经讲述了一些与文件和目录相关的程序。计算机还有其他的数据来源，如调制解调器、打印机、扫描仪、鼠标、扬声器、照相机和终端等这样的外部设备。在本章中将学习这些设备与目录和文件的相似之处和不同之处，并了解如何将这些想法用于管理设备间的连接。

本章的项目是编写命令stty的另外一个版本。stty用来让用户检测、修改控制键盘和显示器连接属性的设置。

## 5.2 设备就像文件

很多人认为文件是一些存储在磁盘上的数据，但是Unix采用一种更抽象的方法。首先考虑文件的实际情形：文件包含数据，具有属性，通过目录中的名字被识别。可以从一个文件读取数据，也可以向一个文件写入数据。现在请注意，这种方法将被应用于设备。

考虑一块连接到麦克风和扬声器的声卡。你对着麦克风说话，声卡将来自你声音的信息转换成数据流，使得程序能够读取这个数据流。当程序向声卡写入数据流时，声音就从扬声器中出来。对一个程序来说，声卡既是数据的来源，又是数据的目的地。

一个带有键盘和显示器的终端也和文件类似。键盘输入就像数据一样能够被程序读取，而一个进程把写入终端的字符显示在屏幕上。

对Unix来说，声卡、终端、鼠标和磁盘文件时同一种对象。在Unix系统中，每个设备都被当做一个文件。每个设备都有一个文件名、一个i-节点号、一个文件所有者、一个权限位的集合和最近修改时间。你所了解的和文件有关的所有内容都将被运用于终端和其他的设备。

设备具有文件名
每个加载到Unix机器的设备（终端、打印机、鼠标、磁盘等）都通过文件名表示。通常，表示设备的文件存放在目录 /dev中，但是可以在任何目录中创建设备文件。请查看不同Unix机器上的 /dev目录。以下是我所使用的机器上的部分列表：
...
这个列表显示了若干种设备。第三列中的lp*文件是打印机。第二列中的fd*文件是软驱。sd*文件是SCSI设备的分区，/dev/tape是磁带备份驱动程序的设备文件。最后一列中的tty*文件是终端。程序通过读取这些文件获得用户的键盘输入，通过写入这些文件向终端屏幕发送数据。
dsp文件是到声卡的一个连接。进程通过向该设备文件写入字节来运行一个声音文件。进程可以通过打开文件/dev/mouse来读取鼠标的单击和位置的变化。
设备和系统调用
设备不仅具有文件名，而且支持与所有文件相关的系统调用：open、read、write、lseek、close和stat。
例如，从磁带读取数据的代码如下：
...
和磁盘文件相关的系统调用同样可以为其他设备服务。实际上，Unix没有其他的方法用来和设备通信。
当你移动鼠标并按键，鼠标将数据发送到系统，使得进程能够读取它们。向设备写入数据意味着什么呢？发送数据到鼠标，不会使鼠标移动，也不会使鼠标的键被按下。/dev/mouse文件不支持所有的write系统调用。当然，可以制造带有发动机的鼠标，然后编写一个更高级的鼠标驱动程序，使得系统能够接受并产生鼠标事件。
终端支持read和write，但不支持lseek。考虑一下这是为什么呢？
例子：终端就像文件
Unix的很多用户输入来自终端。ttysd、ttyse等文件都代表终端。按传统定义终端使键盘和显示单元，但实际可能包括一个20世纪70年代生产的打印机、一个键盘和一个串行接口的显示器，或是一个调制解调器和通过拔号上网的软件。在因特网登录的telnet或ssh窗口也可以认为使一个终端。终端最重要的功能使接收来自用户的字符输入和将输出信息显示给用户。显示输出单元甚至可以产生盲文打印或声音。
命令tty用来告知用户所在终端的文件名。用终端文件做以下试验：

## 5.4 磁盘连接的属性

系统调用open用于在进程和磁盘文件之间创建一个连接。该连接含有若干个属性，下面先仔细学习其中两个属性，然后再了解一下其他属性。

### 属性1: 缓冲

图5.3显示了当两个管道通过一个进程单元连接时文件描述符的情况。那个进程单元是用来进行缓冲和完成其他进程任务的。在方框内的是控制变量，用以决定文件描述应该采取哪个进程步骤。

可以通过修改控制变量改变文件描述符的动作。例如，通过简单的3步操作关闭磁盘缓冲，如图5.4所示。

首先，生成一个系统调用将控制变量从文件描述符复制到进程。然后，修改这个复制过来的控制变量。最后，将修改过的值送回内核。新的设置被安置在进程代码中，内核根据新的设置处理数据。下面是遵循上述3步的代码：

```
#include <fcntl.h>
int s;
s = fcntl (fd, F_GETFL);
s |= O_SYNC;
Result = fcntl (fd, F_SETFL, s);
if (result == 1)
{
    perror (“setting SYNC”);
}
```
fcntl在fd所指定的文件上执行操作cmd。arg 代表操作cmd所使用的一个参数。在上例中，参数F_GETFL得到当前的位集（也就是flags）。变量s存放这个flag集。位逻辑或操作打开位O_SYNC。该位告诉内核，对write的调用仅能在数据写入实际的硬件时才能返回，而不是在数据复制到内核缓冲区时就执行默认的返回操作。

最后，把修改过的设置返回到内核。将F_SETFL操作作为第二个参数，将修改过的设置作为第三个参数。这3个步骤（从内核中读取设置到变量，修改这些设置，将设置返回到内核）是Unix中读取和修改连接属性的典型方法。

### 属性2：自动添加模式

文件描述符的另一个属性是自动添加模式。自动添加模式对于若干个进程在同一时间写入文件是很有用的。

为什么自动添加模式是有用的？

考虑日志文件wtmp。wtmp存储所有的登录和退出记录。当一个用户登录时，程序login在wtmp的末尾追加一条登录记录。当一个用户退出时，系统在wtmp的末尾追加一条退出记录，如同系统维护的日记一样。这就像人们写日记一样，每篇都被添加在末尾。

不能使用lseek在末尾进行添加记录吗？考虑一下登录的逻辑，如图5.5所示。

lseek将当前位置移动到文件的末尾，然后添加登录的记录。这里会产生什么错误呢？如果两个人同时登录将会发生什么？含有时间过程，如图5.6所示。

wtmp文件显示在中间，时间箭头在左边，并显示了4个时间片段。用户A登录的代码显示在左边，用户B登录的代码显示在右边。到现在为止一切都正常吗？一个重要的事实是，Unix是一个时间共享系统，这个过程需要两个独立的步骤：lseek和write。

现在仔细看看下面：
* 时间1——B的登录进程定位到文件末尾
* 时间2——B的时间片用完，A的登录进程定位到文件末尾
* 时间3——A的时间篇用完，B的登录进程写入记录
* 时间4——B的时间片用完，A的登录进程写入记录

因此，A的登录进程写入的记录覆盖了B的记录，B的登录记录丢失。
这种情况被成为竞争（race condition）。这两个进程所共享的网状效应依赖于这两个进程如何规划。在时间方面做一个小的改动，可能A的登录记录会丢失，可能两个记录都不会丢失。

如何避免这种竞争？有很多方法避免竞争。竞争是系统编程所面临的重要问题，后面需要多次回到这个话题。在这个特定的情况中，内核提供一个简单的解决办法：自动添加模式。当文件描述符的O_APPEND位被开启后，每个对write的调用自动调用lseek将内容添加到文件末尾。

下面代码启动自动添加模式，然后调用write:
```
#include <fcntl.h>
int s;
s = fcntl (fd, F_GETFL);
s |= O_APPEND;
Result = fcntl (fd, F_SETFL, s);
if (result == -1)
{
    perror (“setting APPEND”);
}
else
{
    write(fd, &rec, 1);
}
```

术语竞争和原子操作（atomoc operation）密切相关。对lseek和write的调用是独立的系统调用，内核可以随时打断进程，从而使后面这两个操作被中断。当O_APPEND被置位，内核将lseek和write组合成一个原子操作，被连接成一个不可分割的单元。

### 用open控制文件描述符
O_SYNC和O_APPEND是文件描述符的两个属性，其他的属性将在后面的章节中讨论。fcntl的联机帮助列出了你的系统上所支持的所有选项和操作。

fcntl并不是仅有的用来设置文件描述符属性的方法。通常在打开一个文件时，应该直到需要怎样的设置。可以通过系统调用open的第二个参数的一部分来设置文件描述符的属性位。例如，调用:
```
fd = open (WTMP_FILE, O_WRONLY |O_APPEND | O_SYNC);
```
以写方式打开文件wtmp并将O_APPEND和O_SYNC位开启。open的第二个参数不只是读、写或读/写的选择。

例如，可以通过open创建一个包含O_CREAT标志位的文件。以下两个调用是等价的：
```
fd = open (filename, permission_bits);
fd = open (filename, O_CREAT | O_TRUNC | O_WRONLY, permission_bits);
```

为什么open可以实现相同的功能，而creat依旧存在？在老的版本中，open仅仅用来打开文件，creat用来创建新的文件。随后，open被多次修改以支持更多的标志位，包括创建文件选项。

open支持的其他标志位:
O_CREAT		如果不存在，创建该文件。可以查看O_EXCL。
O_TRUNC	如果文件存在，将文件长度置为0。
O_EXCL		该标志位防止两个进程创建同样的文件。如果文件存在且O_EXCL被置位，则返回-1。

O_CREAT和O_EXCL的组合用来消除以下竞争情况：如果两个进程同时创建相同的文件将会发生什么情况？例如，如果两个进程都要写wtmp，但是这个文件不存在时，都要创建该文件，此时会发生什么情况？程序能够先调用stat查看文件是否存在，如果不存在，就调用creat。当stat和creat间的过程被打断时，问题就出现了。O_EXCL/O_CREAT的组合将这两个调用构成一个原子操作。虽然想法很好，但是这种方法在某些重要场合并不可行。一个可靠的替代方案时使用link。本章的练习提供了一个例子。

### 磁盘连接小结

内核在磁盘和进程间传输数据。内核中进行这些传输的代码有很多选项。程序可使用open和fcntl系统调用控制这些数据传输的内部运作，如果5.7所示。

## 5.5终端连接的属性

系统调用open在进程和终端之间创建一个连接。现在来仔细了解一下与终端连接的一些属性。

### 终端的I/O并不如此简单

终端和进程之间的连接看起来简单。通过使用getchar和putchar就能够在设备和进程间传输字节。数据流的这种抽象使得键盘和屏幕看起来就像在进程中一样，如图5.8所示。

一个见到那的实验表明这个模型并不完整。考虑下面这个程序：
```
#include <stdio.h>
main()
{
    int c, n = 0;
    while ( (c  = getchar())!= ‘Q’)
    {
        printf(“char %3d is %c code %d\n”, n++, c, c);
    }
}
```
这个程序以一个接一个的方式处理字符，读取字符，打印数值、字符本身以及它的内部代码。编译并运行这个程序，结果如下所示：

接下来会发生什么事情？如果字符代码直接从键盘流向getchar，则在每个字符后可以看到一个响应。输入单词hello中的5个字符并按回车键。然而，仅在这个时候，程序才开始处理这些字符。输入看起来被缓冲了。就像流向磁盘的数据，从终端流出的数据在沿途中的某个地方被存储起来了。

listchars显示了另外一些内容。Enter键或Return键通常发送ASCII码13，即回车符。listchars的输出显示ASCII码13被换行符（代码10）所替代。

第三种处理影响程序的输出。listchars在每个字符串的末尾添加一个换行符（\n）。换行符代码告诉鼠标移动到下一行，但没有告诉它移到最左边。代码13（回车符）告诉鼠标回到最左端。

运行listchars表明在文件描述符的中间必定有一个处理层。图5.9显示了该层的部分作用。

这个例子说明了3种处理：
+ 进程在用户输入Return后才接收数据；
+ 进程将用户输入的Return（ASCII码13）看作换行符（ASCII码10）；
+ 进程发送换行符，终端接收到回车换行符。

与终端的连接包含一套完整的属性和处理步骤。

### 终端驱动程序

终端的进程之间的连接如图5.10所示。

处理进程和外部设备间数据流的内核子程序的集合被成为终端驱动程序或tty驱动程序。驱动程序包含很多控制设备操作的设置。进程可以读、修改和重置这些驱动控制标志。

### stty命令
stty命令让用户读取和修改终端驱动程序的设置。
* （1）使用stty显示驱动程序设置

stty的输出如下所示：

默认选项的列表很简洁。如加删选项-all则将列出更多的设置。有些设置是有值的变量，有些是布尔值。例如，波特率和屏幕的行数与列数拥有数值。像intr、quit和eof这些项拥有字符值。而像icrnl、-olcuc和onlcr的值是开或关。

这些意味着什么？icrnl是Input: convert Carriage Return to NewLine（输入时将回车转换为换行）的缩写，即在前面的例子中驱动程序所作的操作。缩写onlcr代表Output: add to NewLine a Carriage Return（输出时在新的一行中加入回车）。一个属性前的减号表示这个操作被关闭。例如，-olcuc表示动作Output: convert LowerCase to UpperCase（输出时将小写字母转换成大写字母）被禁止。很多早期的终端只显示大写字母，所以那时将输出转换成大写很有用。

* （2）使用stty改变驱动程序设置

这里是一些使用stty修改驱动程序属性的例子：

$ stty erase X			# make ‘X’ the erase key

$ stty -echo			# type invisibly

$ stty erase @ echo		# multiple requests

在第一个例子中，使用stty用来改变删除键。退格键或删除键是典型设置，但是可以将任何键作为删除键。在第二个例子中，关闭按键回显。当输出密码时，字符并不回显在屏幕上。关闭这个回显意味着能够打字，但是看不到所输入的字符。在第三个例子中，使用stty一次性改变多种设置。同时将删除键改为@，并将回显模式开启。

stty如何运作？现在能够编写stty了吗？

### 编写终端驱动程序：关于设置

tty驱动程序包含很多对传入的数据所进行的操作。这些操作被分为4种：
* 输入：驱动程序如何处理从终端来的字符
* 输出：驱动程序如何处理流向终端的字符
* 控制：字符如何被表示——位的个数、位的奇偶性、停止位等
* 本地：驱动程序如何处理来自驱动程序内部的字符

输入处理包括将小写字母转换位大写字母，去除最高位及将回车符转为换行符。输出处理包括用若干个空格符代替制表符，将换行符转换为回车符将小写字母转换为大写字母。控制设置包括奇偶性及停止位的个数。本地处理包括回显字符给用户及缓冲输入直到用户按回车键。

除了开和关设置外，驱动程序维护了一张含有特殊意义键的列表。例如，用户可能按退格键来删除一个字符。终端驱动程序会注意并处理这个删除键。除此之外，终端驱动程序还负责对其他一些控制字符进行处理。

联机帮助上列出了stty大部分的设置和控制字符。

### 编写终端驱动程序：关于函数

改变终端驱动程序的设置就像改变磁盘文件连接的设置一样：
* （1）从驱动程序获得属性；
* （2）修改要修改的属性；
* （3）将修改后的属性送回驱动程序。

例如，以下代码为一个连接开启字符回显：

### 终端连接小结

终端是人们用来和Unix进程进行通信的设备。终端拥有一个可以让进程读取字符的键盘和可让进程发送字符的显示器。终端是一个设备，所以它在目录树中表现为一个特殊的文件，通常在 /dev这个目录中。

进程和终端间的数据传输和数据处理由终端驱动程序负责，终端驱动程序是内核的一部分。该内核代码提供缓冲、编辑和数据转换。程序可通过调用tcgetattr和tcsetattr查看和修改该驱动程序的设置。

## 5.6 其他设备编程：ioctl

到磁盘文件的连接有一个属性集，到终端的连接有另外一个属性集。到其他类型设备的连接是怎样的呢?

考虑CD刻录机。可擦写的CD能够被删除内容，能以不同的速度刻录CD。扫描仪有自己的设置，如解析度和颜色深度等。其他类型的设备有各自的属性集。程序员如何查看和控制一个设备的设置呢？

每个设备文件都支持系统调用ioctl
...

系统调用ioctl提供对连接到fd的设备驱动程序的属性和操作的访问。每种类型的设备都有自己的属性集和ioctl操作集。
例如，一个终端屏幕，有一个以行和列或者以像素为单位的大小属性。下面的代码显示屏幕的尺寸。
...

符号TIOCGWINSZ是函数代码，wbuf的地址是该设备控制函数的参数。
阅读头文件是了解设备类型以及相关函数的好方法。联机帮助中有关设备的内容也包括属性和函数的列表。例如，Linux中有关st（4）的联机帮助讲述了使用ioctl控制SCSI磁带驱动器的细节。

## 5.7 文件、设备和流

任何数据的源或目的地都被Unix视为文件。基本的系统调用既适用于磁盘文件也同样适用于设备文件，它们的区别体现在对连接的操作上。磁盘文件的文件描述符包含对缓冲属性和扩展属性的定义代码。终端的文件描述符包含编辑、回显、字符转换和其他操作的属性定义代码。

可以把每个处理步骤描述成连接的一个属性，但是反过来说，连接也可以看作是处理步骤的组合。20世纪80年代由AT&T开发的一个Unix版本System V建立了一个以处理序列为基础的数据流模型。这有点像清洗汽车。首先，将肥皂水洒在车上。然后，用大刷子擦去灰尘。下一步，用高压软管将表面的肥皂泡沫和灰尘清除，同时使用车盘锈抑制剂，打赏热蜡，为轮轴盖镀铬。最后，用软布和热空气弄干表面。

当然，每个步骤都是汽车清洗者从汽车清洗公司买来部件完成的。买来之后把它们安置在清洗序列中的某个位置，整个系统就可以工作了。而且，可以进行重组和改造，比如省略某些特定的步骤（注意请不要用热蜡！）。

这是数据流模型和连接属性的流模型的一个大概想法。流模型的一个重要特征是处理的模块化。如果不满意仅能支持像大小写转换这样的终端驱动程序，可以设计并安装一个可将数字转换成罗马数字的模块。也就是，可以编写一个能完成从阿拉伯数字到罗马数字转换的处理模块。将它写到流模型规范，然后，使用特殊的系统调用将该模块安装到系统上。流数据经过它的处理就从阿拉伯数字编程罗马数字了。

在联机帮助上查看streamio以了解更多关于通过这种方式管理连接属性问题的解决方案。在某些版本的Unix中，流用来实现网络服务。

# 第6章 为用户编程：终端控制和信号

## 6.1软件工具与针对特定设备编写的程序

在Unix系统，虽然设备看起来很像磁盘文件，但是设备是不同于磁盘文件的。在第5章中已经看到，程序能对设备执行open、close、read、write和lseek操作，但是也已经看到设备有相应的驱动程序，那些驱动程序包含许多与设备相关的控制和属性。程序如何认识这种双重性？

* 1.软件工具：从stdin或文件输入，写到stdout

对磁盘文件和设备文件不加以区分的程序被称为软件工具。Unix系统有好几百个软件工具，包括who、ls、sort、uniq、grep、tr和du。软件工具使用图6.1所示的模型。

软件工具从标准输入读取字节，进行一些处理，然后将包含结果的字节流写到标准输出。工具发送错误消息到标准错误输出，它们也被当做简单的字节流来处理。这些文件描述符能够连接到文件、终端、鼠标、光电管、打印机和管乐器；工具对所处理的数据的源和目的地不做任何假设。其他很多程序也能从命令行所指定的文件中读取数据。

这些程序的输入和输出能够被重定向到任何类型的连接上：

* 2.特定设备程序：为特定应用控制设备

其他程序（如控制扫描仪、记录压缩盘、操作磁带驱动程序和拍摄数码相片的程序）也能同特定设备进行交互。在本章中将通过了解最常见的与特定设备相关的程序（通过终端与人交互的程序）来探讨在写这些程序时用到的概念和技术。将这些面向终端的程序称为用户程序。

* 3.用户程序：一种常见的设备相关程序

用户程序的例子有vi、emacs、pine、more、lynx、hangman、robots和许多加利福尼亚大学伯克利分校编写的游戏程序。这些程序设置终端驱动程序的击键和输出处理方式。驱动程序有很多设置，但是用户程序常用到的有：
* （1）立即响应击键事件
* （2）有限的输入集
* （3）输入的超时
* （4）屏蔽Ctrl-C

下面将通过编写一个实现所有这些特点的程序来学习这些主题。

## 6.2终端驱动程序的模式

## 6.3编写一个用户程序：play_again.c

## 6.4信号