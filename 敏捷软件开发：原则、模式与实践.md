- [第Ⅰ部分 敏捷开发](#第ⅰ部分-敏捷开发)
  - [第 1 章 敏捷实践](#第-1-章-敏捷实践)
  - [第 2 章 极限编程概述](#第-2-章-极限编程概述)
    - [2.1 极限编程实践](#21-极限编程实践)
      - [2.1.1 客户作为团队成员](#211-客户作为团队成员)
  - [第 3 章 计划](#第-3-章-计划)
    - [3.1 初始探索](#31-初始探索)
  - [第 4 章 测试](#第-4-章-测试)
    - [4.1 测试驱动的开发方法](#41-测试驱动的开发方法)
      - [4.1.1 一个测试优先设计的示例](#411-一个测试优先设计的示例)
      - [4.1.2 测试促使模块之间隔离](#412-测试促使模块之间隔离)
      - [4.1.3 意外获得的解耦合](#413-意外获得的解耦合)
    - [4.2 验收测试](#42-验收测试)
      - [4.2.1 验收测试示例](#421-验收测试示例)
    - [4.3 结论](#43-结论)
  - [第 5 章 重构](#第-5-章-重构)
    - [5.1 素数产生程序：一个简单的重构示例](#51-素数产生程序一个简单的重构示例)
  - [第 6 章 一次编程实践](#第-6-章-一次编程实践)
- [第Ⅱ部分 敏捷设计](#第ⅱ部分-敏捷设计)
  - [第 8 章 单一职责原则（SRP）](#第-8-章-单一职责原则srp)
    - [8.1 单一职责原则](#81-单一职责原则)
    - [8.1 定义职责](#81-定义职责)
    - [8.2 分离耦合的职责](#82-分离耦合的职责)
    - [8.3 持久化](#83-持久化)
    - [8.4 结论](#84-结论)
  - [第 17 章 用例](#第-17-章-用例)
    - [17.1 编写用例](#171-编写用例)
      - [17.1.1 备选流程](#1711-备选流程)
      - [17.1.2 其他东西呢](#1712-其他东西呢)
    - [17.2 结论](#172-结论)
- [第 Ⅲ 部分 薪水支付案例研究](#第-ⅲ-部分-薪水支付案例研究)
- [第 Ⅳ 部分 打包薪水支付系统](#第-ⅳ-部分-打包薪水支付系统)
- [第 Ⅴ 部分 气象站案例研究](#第-ⅴ-部分-气象站案例研究)
- [第 Ⅵ 部分 ETS 案例研究](#第-ⅵ-部分-ets-案例研究)

# 第Ⅰ部分 敏捷开发

## 第 1 章 敏捷实践

## 第 2 章 极限编程概述

**作为开发人员，我们应该记住，XP 并非惟一选择**

在上一章中，我们简要介绍了有关敏捷软件开发方法方面的内容，但它没有确切地告诉我们去做些什么；其中给出了一些泛泛地陈述和目标，却没有给出实际的直到方法。本章要改变这种状况。

### 2.1 极限编程实践

极限编程（eXtreme Programming，简称 XP）是敏捷方法中最著名的一个。它由一系列简单却相互依赖的实践组成。这些实践结合在一起形成了一个胜于部分结合的整体。本章我们将简要地探讨一下这个整体，在后续地章节中，会对一些单独地实践进行研究。

#### 2.1.1 客户作为团队成员

我们希望客户和开发人员在一起紧密地工作，以便于彼此知晓对方所面临地问题，并共同去解决这些问题。

谁是客户？XP 团队中的客户是指定义产品的特性并排列这些特性优先级的人或团体。有时，客户是和开发人员同属一家公司的一组业务分析师或者市场专家。有时，客户是用户团体委派的用户代表。有时，客户事实上是支付开发费用的人。但是在 XP 项目中，无论谁是客户，他们都是能够和团队一起工作的团队成员。

最好的情况是客户和开发人员在同一个房间中工作，次一点的情况是客户和开发人员之间的工作距离在 100 米以内。距离越大，客户就约难成为真正的团队成员。如果客户工作在另外一幢建筑或另外一个州，那么他将很难融合到团队中来。

如果确实无法和客户在一起工作，该怎么办呢？我的建议是去寻找能够在一起工作、愿意并能够代替真正客户的人。

## 第 3 章 计划

**当你能够度量你所说的，并且能够用数字去表达它时，就表示你了解了它；若你不能度量它，不能用数字去表达它，那么说明你的知识就是匮乏的、不能令人满意的。**

下面的内容是对极限编程（XP）中计划游戏（planning game）部分的描述。它和在其他敏捷方法（如 SCRUM、Crystal、Feature-Driven Development，简称 FDD、Adaptive Software Development，简称 ADP）中做计划的方式相似。不过，那些过程方法都没有极限编程对此描述得详细、精确。

### 3.1 初始探索

在项目开始时，开发人员和客户会尽量确定出所有真正的用户故事。然而，他们不会试图去确定所有的用户故事。随着项目的进展，客户会不断编写新的用户故事。素材的编写会一直持续到项目完成。

开发人员共同对这些素材进行估算。估算是相对的，不是绝对的。我们在记录素材的卡片上写上一点“点数”来表示实现这个素材所需要的相对时间。我们可能不能确定一个“点”代表多少时间，但是我们知道实现 8 个点的素材所需要的时间是实现 4 个点的两倍。

**探究、分解和速度**

过大或者多小的素材都是难以估算的。开发人员往往会低估哪些大大的素材而高估那些小的素材。任何过大的素材都应该被分解成小一点的部分，任何过小素材都应该和其他小的素材合并。

例如，考虑下面这个用户素材：“用户能够安全地进行存款、取款、转账活动。”

## 第 4 章 测试

**烈火验真金，逆境磨意志。**

编写单元测试是一种验证行为，更是一种设计行为。同样，它更是一种编写文档的行为。编写单元测试避免了相当数量的反馈循环，尤其是功能验证方面的反馈循环。

### 4.1 测试驱动的开发方法

如果我们能够在设计程序前先设计测试方案，情况会怎样？如果我们能够做到：除非缺乏某个功能将导致测试失败，否则就拒绝在程序中实现该功能，情况会怎样？如果我们能做到：除非由于缺少某行代码将导致测试失败，否则就拒绝在程序中增加哪怕一行代码，情况又会怎样？如果首先编写失败的测试表明需要一项功能，然后再逐渐地增加那项功能使测试通过，情况又会怎么样？这对于我们正在编写的软件的设计有什么影响呢？如果存在这样一组包罗万象的测试，我们能够从中得到什么好处？

第一个也是最明显的一个影响，是程序中的每一项功能都有测试来验证它的操作的正确性。这个测试套件可以给以后的开发提供支援。无论何时我们因疏忽破坏了某些已有的功能，它就会告诉我们。我们可以向程序中增加功能，或者更改程序结构，而不用担心在这个过程中会破坏重要的东西。测试告诉我们程序仍然具有正确的行为。这样，我们就可以更自由地对程序进行改进。

此外，通过首先编写测试，我们就迫使自己把程序设计为可测试的。把程序设计为易于调用和可测试的，是非常重要的。为了成为易于调用和可测试的，程序必须和它的周边环境解耦。这样，首先编写测试迫使我们解除软件中的耦合（forces us to decouple the software)。

首先编写测试的另一个重要效果，是测试可以作为一种无价的文档形式。如果想知道如何调用一个函数或者创建一个对象，会有一个测试展示给你看。测试就像一套范例，它帮助其他程序员了解如何使用代码。这份文档是可编译、可运行的。它保持最新。它不会撒谎。

#### 4.1.1 一个测试优先设计的示例

最近，我编写了一个名为“Hunt the Wumpus”的程序，仅仅是为了好玩。这是一个简单的冒险类游戏，玩家在洞穴中移动，设法在被 Wumpus 吃掉前杀掉 Wumpus。洞穴是由一系列通过过道互相连接的房间组成。每一个房间可以具有通向东、南、西、北方向的通道。玩家通过告诉计算机要行走的方向而四处移动。

在我为这个程序首先编写的测试中，有一个是程序 4.1 中的 testMove。这个函数创建了一个新的 WumpusGame 对象，通过一个东面的通道把房间 4 连接到房间 5，把玩家放置在房间 4 中，发出了向东移动的命令，接着断言玩家应该在房间 5 中。

**程序 4.1**
```
public void testMove()
{
  WumpusGame g = new WumpusGame();
  g.connect(4,5,"E");
  g.setPlayerRoom(4);
  g.east();
  assertEquals(5, g.getPlayerRoom());
}
```

这段测试代码是在编写 WumpusGame 程序前完成的。我采用了 Ward Cunningham 的建议，按照便于我们自己阅读的方式编写了这个测试。我相信只要按照测试所暗示的结构去编写 WumpusGame 程序，就能够通过测试。这种方法称为有意图的编程（intentional programming）。在实现之前，先在测试中陈述你的意图，使你的意图尽可能地简单、易读。你相信这种简单和清楚会给程序指出一个好的结构。

揭示意图编程（programming by intent）立即引导我产生了一个有趣的决定。测试代码中没有使用 Room 类。把一个房间连接到另一个房间的动作传达了我的意图。看起来，我不需要一个 Room 类来使表达更加容易。相反，我可以仅仅使用整数来表示房间。

这看起来好像不够直观。毕竟，这个游戏在你看来都是关于房间的，在房间之间移动，发现房间中包含的东西，等待。由于缺乏了一个 Room 类，我的意图所暗示的设计就有缺陷了吗？

我可以说在 Wumpus 游戏中，连接（connnection）这个概念要比房间的概念重要得多。我可以说最初的测试指出了一个好的解决问题的方法。的确，我认为事情是这样的，但是那并不是我试图想让大家特别注意的。我想让大家特别注意的是测试在非常早的阶段就为我们阐明了一个重要的设计问题。首先编写测试的行为就是在各种设计决策中进行辨别的行为。

注意，测试告诉了我们程序是如何工作的。我们中的大多数都可以非常容易地根据这个规格说明实现 WumpusGame 的 4 个已经命名了的方法。同样，命名并实现其他 3 个方向的命令也没有什么困难的。如果以后我们想知道如何把两个房间连接起来，或者如何朝一个特定的方向移动，这个测试会直截了当地展示给我们该如何去做。

#### 4.1.2 测试促使模块之间隔离

在编写产品代码之前，先编写测试常常会暴露程序中应该被解耦合地区域。例如，图 4.1 展示了一个薪水支付应用（payroll application）的简单 UML 图。类 Payroll 使用 EmployDatabase 获得 Employee 对象，它要求 Employee 去计算自己的薪水。接着，它把计算结果传递给 CheckWriter 对象产生出一张支票。最后，它在 Employee 对象中记录下支付信息，并把 Employee 对象写回到数据库中。

假定还没有编写任何代码，这个图也是在经历了快速的设计讨论后，刚刚才画在白板上的。现在，需要编写规定 Payroll 对象行为的测试。有许多和编写这些测试相关的问题。首先，要使用什么数据库呢？Payroll 对象需要从若干种类的数据库中读取数据。我们必须要在能够对 Payroll 类进行测试前，编写一个功能完善的数据库吗？我们要把什么数据加载到数据库中呢？其次，我们如何来验证打印出来的支票的正确性？我们无法编写出一个能够观察打印机打印出来的支票并验证上面的数额正确性的自动测试程序来。

使用 MOCK OBJECT 模式可以解决这些问题。我们可以在 Payroll 类以及它的所有协作者之间插入接口，创建实现这些接口的测试桩（test stub）。

图 4.2 展示了这个结构。现在，Payroll 类使用接口和 EmployeeDatabase、CheckWriter以及Employee 进行通信，创建了 3 个实现这些接口的 MOCK OBJECTS。PayrollTest 对象对这些 MOCK OBJECTS 进行查询，来检验 Payroll 对象是否正确地对它们进行了管理。

程序 4.2 展示了测试的意图。测试中创建了合适的 MOCK OBJECTS，把它们传递给 Payroll 对象，告诉 Payroll 对象为所有雇员支付薪水，接着要求 MOCK OBJECTS 去验证所有已开支票的正确性以及所有已记录支付信息的正确性。

当然，这个测试所检查的都是 Payroll 应该使用正确的数据调用正确的函数。它既没有真正地去检查支票的打印，也没有真正地去检查一个真实数据库的正确刷新。相反，它检查了 Payroll 类应该具有与它在独立情况下同样的行为。

你也许想知道为何需要 MockEmployee 类。看起来好像可以直接使用真实的 Employee 类。如果真是那样，我会毫不在乎地使用它。在本例中，我认为对于检查 Payroll 类的功能来说，Employee 类显得复杂了点。

**程序 4.2**
```
public void testPayroll()
{
  MockEmployeeDatabase db = new MockEmployeeDatabase();
  MockCheckWriter w = new MockCheckWriter();
  Payroll p = new Payroll(db, w);
  p.payEmployees();
  assert(w.checksWereWrittenCorrectly());
  assert(db.paymentsWerePostedCorrectly());
}
```

#### 4.1.3 意外获得的解耦合

对于 Payroll 类的解耦合是件好事。这允许我们可以互换使用不同种类的数据库和支票打印机，这种互换能力既是为了测试，也是为了应用的扩展性。我觉得为了进行测试而进行解耦合是有趣的。显然，为了测试而对模块进行隔离的需要，迫使我们以对整个程序结构都有益的方式对程序进行解耦合。在编写代码前先编写测试改善了设计。

本书中的大部分内容是依赖性管理方面的设计原则。这些原则在解耦合和包方面提供了一些指导技术。如果把这些原则作为单元测试策略的一部分来实践它们，就会发现这些原则是非常有用的。正是单元测试在解耦合方面提供了很多的推动和指导。

### 4.2 验收测试

作为验证工具来说，单元测试是必要的，但是不够充分。单元测试用来验证系统的小的组成单元应该按照所期望的方式工作，但是它们没有验证系统作为一个整体时工作的正确性。单元测试是用来验证系统中个别机制的白盒测试（white-box tests）。验收测试是用来验证系统满足客户需求的黑盒测试（black-box tests）。

验收测试由不了解系统内部机制的人编写。客户可以直接或者和一些技术人员（可能是 QA 人员）一起来编写验收测试。验收测试是程序，因此是可以运行的。然而，通常使用专为应用程序的客户创建的脚本语言来编写验收测试。

验收测试是关于一项特性（feature）的最终的文档。一旦客户编写完成了验证一项特性的验收测试，程序员就可以阅读那些验收测试来真正地理解这项特性。所以，正如单元测试作为可编译、运行的有关系统内部结构的文档那样，验收测试是有关系统特性的可编译、执行的文档。

此外，首先编写验收测试的行为对于系统的架构方面具有深远的影响。为了使系统具有可测试性，就必须要在很高的系统架构层面对系统进行解耦合。例如，为了使验收测试无需通过用户界面（UI）就能获得对于业务规则的访问，就必须要比满足这个目的的方式来解除用户界面和业务规则之间的耦合。

在项目迭代的初期，会受到用手工的方式进行验收测试的诱惑。但是，这样做使得在迭代的初期就丧失了由自动化验收测试的需要带来的对系统进行解耦合的促进力，所以是不明智的。当在最早开始迭代时，如果非常清楚地知道必须要自动化验收测试，就会做出非常不同的系统架构方面的权衡。并且，正如单元测试可以促使你在小的方面做出优良的设计决策一样，验收测试可以促使你在大的方面做出优良的系统架构决策。

创建一个验收测试框架看起来是件困难的任务。然而，如果仅仅创建框架中对单个迭代包含的特性进行验收测试所需要的那部分，就会发现并不困难。你还会发现所花费的努力是值得的。

#### 4.2.1 验收测试示例

再次考虑一下薪水支付应用程序。在首次迭代中，必须能够向数据库中增加和删除雇员。必须能够为当前存在数据库中的雇员创建支付薪水的支票。还好，此次只需处理带薪雇员（salaried employees）。其他种类的雇员可以放在后面的迭代中处理。

我们还没有编写任何代码，也没有进行任何设计。这是开始考虑验收测试的最好机会，揭示意图编程再一次成为有用的工具。我们应该以我们认为验收测试应该的样子去编写它们，然后可以构造脚本语言，并根据脚本语言的结构来构造薪水支付系统。

我想使验收测试便于编写并且易于改变。我想把它们放置在一个配置管理工具中，并且把它们保存起来以便于随时可以运行它们。因此，采用简单的文本文件来编写验收测试应该是比较合理的。

下面是一段验收测试脚本的例子：
```
AddEmp  1429 "Robert Martin"  3215.88
Payday
Verify  Paycheck  EmpId 1429  Grosspay  3215.88
```
在这个例子中，我们把雇员号为 1429 的雇员存入数据库。他的名字叫“Robert Martin”，他每月的薪水是 3215.88 美元。接着，我们告诉系统发薪日到了，该给所有的雇员发放薪水了。最后，我们核实产生了一张雇员号为 1429，Grosspay 域的值为 3215.88 的支票。

很明显，客户可以非常容易地编写这种脚本。同样，也非常容易在这种脚本中增加新的功能。然而，我们要考虑一下它所暗示的系统结构。

脚本的头两行针对的是薪水支付应用的功能。

### 4.3 结论


## 第 5 章 重构

**大千世界中，惟一缺乏的就是人类的注意力。**

本章讲述的是关于人的注意力的。阐述人们应该专注于手边的工作并且确信自己正在尽全力，说明了使事物能够工作和使事物正确之间的区别，介绍了我们放入代码结构中的价值。

在 Martin Fowler 的名著《重构》一书中，他把重构（Refactoring）定义为：“...在不改变代码外在行为的前提下对代码做出修改，以改进代码的内部结构的过程。”可是我们为什么要改进已经能够工作的代码的结构呢？不是还有句古老的谚语，“如果它没有坏，就不要去修理它！”吗？

每一个软件模块都具有三项职责。第一个职责是它运行起来所完成的功能。这也是该模块得以存在的原因。第二个职责是它要应对变化。几乎所有的模块在它们的生命周期中都要变化，开发者有责任保证这种改变应该尽可能地简单。一个难以改变的模块是拙劣的，即使能够工作，也需要对它进行修正。第三个职责是要阅读它的人能够理解。对该模块不熟悉的开发人员应该能够比较容易地阅读并理解它。一个无法被理解的模块也是拙劣的，同样需要对它进行修正。

怎样才能让软件模块易于阅读、易于修改呢？本书的主要内容都是关于一些原则和模式的，使用这些原则和模式可以帮助你创建更加灵活和具有适应性的软件模块。然而，要使软件模块易于阅读和修改，所需要的不仅仅是一些原则和模式。还需要你的注意力，需要纪律约束，需要创造美的激情。

### 5.1 素数产生程序：一个简单的重构示例

观察程序 5.1 中所示的代码，这个程序会产生素数。它是一个大函数，其中有辅助阅读的注释和很多单字母变量。

**程序 5-1 GeneratePrimes.cs，版本 1**
```
using System;
public class GeneratePrimes
{
  public static int[] GeneratePrimeNumbers(int maxValue)
  {
    if (maxValue >= 2)
    {
      int s = maxValue + 1;
      bool[] f = new bool[s];
      int i;
      
      for (i = 0; i < s; i++)
      {
        f[i] = true;
      }
      
      f[0] = f[1] = false;
      int j;
      for (i = 2; i < Math.Sqrt(s) + 1; i++)
      {
        if(f[i])
        {
          for (j = 2 * i; j < s; j += i)
          f[j] = false;
        }
      }
      
      int count = 0;
      for (i = 0; i < s; i++)
      {
        if (f[i])
        {
          count++;
        }
      }

      int[] primes = new int[count];
      for (i = 0, j = 0; i < s; i++)
      {
        if (f[i])
        {
          primes[j++] = i;
        }
      }
      return primes;
    }
    else
    {
      return new int[0];
    }
  }
}
```

为 GeneratePrimes 编写的单元测试可以参见程序 5.2。它采用了一种统计学的方法，主要检查产生器能否产生 0、2、3 以及 100 以内的素数。在第一种情况下，应该没有素数；在第二种情况下，应该有一个素数，并且该素数应该是 2；在第三种情况下，应该有两个素数，它们应该是 2 和 3。在最后一种情况下，应该有 25 个素数，其中最后一个是 97。如果所有这些测试都通过了，那么就认为产生器是可以工作的。我怀疑这种做法的可靠性，但是我不能想象出一个合理的情况，在这个情况下这些测试都将通过但是函数却是错误的。

**程序 5.2 GeneratePrimesTest.cs**
```
using NUnit.Framework;
[TestFixture]
public class GeneratePrimesTest
{
  [Test]
  public void TestPrimes()
  {
    int[] nullArray = GeneratePrimes.GeneratePrimeNumbers(0);
    Assert.AreEqual(nullArray.Length, 0);
    int[] minArray = GeneratePrimes.GeneratePrimeNumbers(2);
    Assert.AreEqual(minArray.Length, 1);
    Assert.AreEqual(minArray[0], 2);
    int[] threeArray = GeneratePrimes.GeneratePrimeNumbers(3);
    Assert.AreEqual(threeArray.Length, 2);
    Assert.AreEqual(threeArray[0], 2);
    Assert.AreEqual(threeArray[1], 3);
    int[] centArray = GeneratePrimes.GeneratePrimeNumbers(100);
    Assert.AreEqual(centArray.Length, 25);
    Assert.AreEqual(centArray[24], 97);
  }
}
```

## 第 6 章 一次编程实践

# 第Ⅱ部分 敏捷设计

## 第 8 章 单一职责原则（SRP）

**只有佛自己应当担负起公布玄妙秘密的职责。**

单一职责原则曾经在 Tom Demaro 和 Meilir Page-Jones 的著作中描述过，并称之为内聚性。他们把内聚性定义为：一个模块的组成元素之间的功能相关性。在本文章中，我们稍微改变一下它的含义，把内聚性和引起一个模块或者类改变的作用力联系起来。

### 8.1 单一职责原则

就一个类而言，应该仅有一个引起它变化的原因

考虑第 6 章中保龄球比赛的例子。在开发它的大部分时间内，Game 类一直具有两个不同的职责。一个职责是跟踪当前轮的比赛，另一个职责是计算比赛的得分。最后，RCM和RSK把这两个职责分离到两个类中。Game类保持跟踪每一轮比赛的职责，Scorer类负责计算比赛的得分。

为何要把这两个职责分离到单独的类中呢？因为每一个职责都是一个变化轴线。当需要变化时，该变化会反映为类的职责变化。如果一个类承担了多于一个职责，那么引起它变化的原因就会有多个。

如果一个类承担的职责过多，就等于把这些职责耦合在了一起。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。

例如，考虑图 1 中的设计。Rectangle 类具有两个方法，如果所示。一个方法把矩形绘制在屏幕上，另一个方法计算矩形的面积。

有两个不同的应用程序使用 Rectangle 类。一个应用程序是有关计算几何学方面的，使用 Rectangle 类来处理几何形状的数据运算，但它从来不会在屏幕上绘制矩形。另一个应用程序实质上有关图形绘制方面的，它也可能会进行一些几何运算，但它可能会在屏幕上绘制矩形。

这个设计违反了单一职责原则。Rectangle 类具有两个职责。第一个职责提供了一个矩形几何形状的数学运算模型；第二个职责是在 GUI 上渲染矩形。

对于 SRP 的违反导致了一些严重问题。首先，我们必须在计算几何应用程序中包含进 GUI 代码。在 .NET 中，就必须要把 GUI 组件和计算几何应用一起构建、部署。

其次，如果 GraphicalApplication 的改变由于一些原因导致了 Rectangle 的改变，那么这个改变会迫使我们重新构建、测试以及部署 ComputionalGeometryApplication。如果忘记了这样做，ComputationalGeometryApplication 可能会以不可预测的方式失败。

一个较好的设计是把这两个职责分离到图 8-2 中所示的两个完全不同的类中。这个设计把 Rectangle 类中进行计算的部分移到 GeometricRectangle 类中。现在矩形绘制方式的改变不会对 ComputationalGeometryApplication 造成影响。

### 8.1 定义职责

在 SRP 中，我们把职责定义为变化的原因。如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。有时，我们很难注意到这一点。我们习惯于以组的形式去考虑职责。例如，考虑代码清单 8-1 中的 Modem 接口。大多数人认为这个接口看起来非常合理。该接口所声明的 4 个函数确实是调职解调器所具有的功能。

**代码清单 8-1 Modem.cs — 违反SRP**
```
public interface Modem
{
  public void Dial(String pno);
  public void Hangup();
  public void Send(char c);
  public char Recv();
}
```

然而，该接口中却显示出两个职责。第一个职责是连接管理；第二个职责数据通信。dial 和 hangup 函数进行调职解调器的连接处理，而 send 和 recv 函数进行数据通信。

这两个职责应该分开吗？这依赖于应用程序变化的方式。如果应用程序的变化会影响连接函数的签名，那么这个设计就具有僵化性的臭味，因为调用 send 和 recv 的类必须要重新编译、部署的次数常常会超过我们希望的次数。在这种情况下，这两个职责应该被分离，如图 8-3 中所示。这样做避免了客户应用程序和这两个职责耦合在一起。

另一方面，如果应用程序的变化方式总是导致这两个职责同时变化，那么就不必分离它们。实际上，分离它们就会具有不必要的复杂性的臭味。

在此还有一个推论。仅当变化发生时，变化的轴线才具有实际意义。如果没有征兆，那么应用 SRP 或者任何其他原则都是不明智的。

### 8.2 分离耦合的职责

请注意，在图 8-3 中，我把两个职责都耦合进了 ModemImplementation 类中。这不是所希望的，但是或许是必要的。常常会有一些和硬件或者操作系统的细节有关的原因，迫使我们把不愿耦合在一起的东西耦合在一起。然而，对于应用的其余部分来说，通过分离它们的接口我们已经解耦了概念。

我们可以把 ModemImplementation 类看作是一个杂凑物，或者有缺陷的类。然而，请注意所有的依赖关系都是从它发出的。谁也不需要依赖于它。除了 main 外，谁也不需要知道它的存在。因此，我们已经把丑陋的部分隐藏起来了。其丑陋性不会泄漏出来，污染应用程序的其他部分。

### 8.3 持久化

图 8-4 展示了一种常见的违反 SRP 的情形。Employee 类包含了业务规则和对于持久化的控制。这两个职责在大多数情况下绝不应该混合在一起。业务规则往往会频繁地变化，而持久化的方式却不会如此频繁地变化，并且变化地原因也是完全不同的。把业务规则和持久化子系统绑定在一起的做法是自讨苦吃。

幸运的是，正如我们在第 4 章看到的，测试驱动开发实践常常会远在设计出现臭味之前就迫使我们分离这两个职责。然而，如果测试没有迫使这种分离，而僵化性和脆弱性的臭味又很强烈，那么就应该使用 FACADE（外观）、DAO（数据访问对象）或者 PROXY（代理）模式对设计进行重构，分离这两个职责。

### 8.4 结论

SRP 是所有原则中最简单的原则之一，也是最难正确运用的原则之一。我们会自然地把职责结合在一起。软件设计真正要做的许多工作，就是发现职责并把那些职责相互分离。事实上，我们将要论述的其余原则都会以这样或那样的方式回到这个问题上。

## 第 17 章 用例

用例是一种非常好的思想，却被极大地过度复杂化了。我总是会看到一些开发团队围坐在一起，讨论用例该如何编写。一般来说，这种团队更多的是在关注形式而非内容。他们在前置条件、后置条件、主参与者、辅助参与者以及一堆根本不重要的事情上争论不休。

使用用例真正的窍门就是保持简单。不要担心用例的格式；简单地把它们写在空白纸、字处理器的空白页或空白的索引卡片上就行了。不要担心需要填写所有的细节。细节只有到了很后期才有用。不必为记录所有的用例而烦恼，那是一项不可能完成的任务。

关于用例，有一点要牢记：**明天，他将会变化。**不管你多么努力地记录它们，不管你在记录细节方面多么地一丝不苟，不管你考虑得多么全面，不管你在研究和分析需求上投入了多少精力：明天，它们将会变化。

如果有些东西明天会变化，那么就不必再今天就记录下它的细节。事实上，你要做的就是把细节的记录推迟到最后一刻。请把用例看作是即时需求。

### 17.1 编写用例

请注意本节的标题。我们是要编写用例，不是画它们。用例不是图示。用例是从一个特定视角进行编写的关于行为需求的文本描述。

“等等！”你喊道，“我知道 UML 中有用例图，我曾经见过。”

不错，UML 中确实有用例图。不过从这些图中你根本看不出任何有关用例的内容。它们根本没有包含任何关于行为需求的信息，而这正是用例该记录的内容。UML 中的用例图记录的完全是其他一些东西。

用例是对系统行为的描述。该描述是从一个让系统完成一些特定工作的用户的视角编写的。用例记录了系统响应单个用户行为所经历的可视事件序列。

可视事件指的是用户能够看得到的事件。用例根本不用描述那些看不见的行为，也不描述那些看不到的系统机制。它们只描述用户能够看得到的东西。

用例通常被分为两部分。第一部分为基本流程（primary course）。在这部分中，我们描述在一切正常的情况下系统是如何响应用户行为的。

例如，下面是销售终端系统的一个典型用例。

**卖出商品**

 * 收银员在扫描器上划过商品，扫描器读取 UPC 码。
 * 商品的价格、描述以及当前价格总数出现在朝向顾客的显示器上。价格和描述也出现在收银员的屏幕上。
 * 价格和描述打印在收条上。
 * 系统发出可以听到的“确认”声音以通知收银员 UPC 码正确读取。

这就是一个用例的基本流程。不需要任何更复杂的东西。事实上，如果用例不是一会儿就要实现，那么即使是上面这几个简单的步骤可能也过于详细了。如果用例不需要在几天或者一周内就要实现，我们是不想记录这种细节的。

如果没有记录下用例的细节，如何才能对它进行估算呢？你可以去询问利益相关者有关细节的内容，不必把它记录下来。这会为你提供进行粗略估算所需要的信息。既然要去询问利益相关者一些细节方面的内容，为什么不把它们记录下来呢？因为明天，细节将会变化。难道变化不会影响到估算吗？会影响的，不过对于大量的用例来说，这些影响会相互抵消。过早地记录下细节是完全不划算的。

如果我们现在不去记录用例的细节，那记录什么呢？如果不写下一些东西，我们又如何知道存在用例呢？记下用例的名字即可。在电子表格或者字处理器文档中保持用例名字的代码清单。更好的做法是，把用例的名字写在索引卡片上，并维持一个用例卡片栈。当接近实现时填入细节。

#### 17.1.1 备选流程

有些细节关注的是那些出错的情况。在和利益相关者交谈期间，你会希望谈论一些出问题的场景。之后，随着越来越接近用例的实现时间，你会越来越多地考虑这些备选流程。备选流程是用例基本流程地补充。它们可以按照如下方式编写。

**无法读取 UPC 码**

如果扫描器无法读取 UPC 码，系统应该发出“重新扫描”声音，以通知收银员再试一次。如果重试三次仍然失败，那么收银员应该手工输入 UPC 码。

**没有 UPC 码**

如果商品上没有 UPC 码，那么收银员应该手工输入价格。

这些备选流程非常有趣，因为它们提供了存在其他用例的线索，而这些用例可能是利益相关者一开始没有识别出来的。在本例中，能够手工输入 UPC 或者价格显然是必要的。

#### 17.1.2 其他东西呢

参与者、辅助参与者、前置条件、后置条件以及其他东西是怎么回事呢？不必担心所有这些东西。对于你将从事的绝大多数系统而言，都不必知道这些内容。当需要了解更多的用例知识时，你可以阅读 Alistair Cockburn 关于这个主题的权威著作。现在，在学跑之前先学会走吧。请先掌握简单用例的编写。当你精通这些之后（也就是已经成功地在项目中使用了），才可以非常小心、克制地采用一些更为复杂地技术。但是，一定要记住，不要坐下来想象。

### 17.2 结论

本章很短。这是合适的，因为本章的主题本身比较简单。你对用例的态度一定要保持这种简单性。如果你陷入了用例复杂性的黑暗面，它就会永远控制你的命运。请尽量保持用例简单。

# 第 Ⅲ 部分 薪水支付案例研究

# 第 Ⅳ 部分 打包薪水支付系统

# 第 Ⅴ 部分 气象站案例研究

# 第 Ⅵ 部分 ETS 案例研究
