- [前言](#前言)
- [第Ⅰ部分 敏捷开发](#第ⅰ部分-敏捷开发)
  - [第 1 章 敏捷实践](#第-1-章-敏捷实践)
    - [1.1 敏捷联盟](#11-敏捷联盟)
      - [1.1.1 人和交互重于过程和工具](#111-人和交互重于过程和工具)
      - [1.1.2 可以工作的软件重于面面俱到的文档](#112-可以工作的软件重于面面俱到的文档)
      - [1.1.3 客户合作重于合同谈判](#113-客户合作重于合同谈判)
      - [1.1.4 随时应对变化重于遵循计划](#114-随时应对变化重于遵循计划)
    - [1.2 原则](#12-原则)
    - [1.3 结论](#13-结论)
  - [第 2 章 极限编程概述](#第-2-章-极限编程概述)
    - [2.1 极限编程实践](#21-极限编程实践)
      - [2.1.1 完整团队](#211-完整团队)
      - [2.1.2 用户故事](#212-用户故事)
      - [2.1.3 短交付周期](#213-短交付周期)
      - [2.1.4 验收测试](#214-验收测试)
      - [2.1.5 结对编程](#215-结对编程)
      - [2.1.6 测试驱动开发](#216-测试驱动开发)
      - [2.1.7 集体所有权](#217-集体所有权)
      - [2.1.8 持续集成](#218-持续集成)
      - [2.1.9 可持续的开发速度](#219-可持续的开发速度)
      - [2.1.10 开放的工作空间](#2110-开放的工作空间)
      - [2.1.11 计划游戏](#2111-计划游戏)
      - [2.1.12 简单设计](#2112-简单设计)
      - [2.1.13 重构](#2113-重构)
      - [2.1.14 隐喻](#2114-隐喻)
    - [2.2 结论](#22-结论)
  - [第 3 章 计划](#第-3-章-计划)
    - [3.1 初始探索](#31-初始探索)
    - [3.2 发布计划](#32-发布计划)
    - [3.3 迭代计划](#33-迭代计划)
    - [3.4 定义“完成”](#34-定义完成)
    - [3.5 任务计划](#35-任务计划)
    - [3.6 迭代](#36-迭代)
    - [3.7 跟踪](#37-跟踪)
    - [3.8 结论](#38-结论)
  - [第 4 章 测试](#第-4-章-测试)
    - [4.1 测试驱动的开发方法](#41-测试驱动的开发方法)
      - [4.1.1 测试优先设计的示例](#411-测试优先设计的示例)
      - [4.1.2 测试促使模块之间隔离](#412-测试促使模块之间隔离)
      - [4.1.3 意外获得的解耦合](#413-意外获得的解耦合)
    - [4.2 验收测试](#42-验收测试)
      - [4.2.1 验收测试示例](#421-验收测试示例)
    - [4.3 意外获得的架构](#43-意外获得的架构)
    - [4.4 结论](#44-结论)
  - [第 5 章 重构](#第-5-章-重构)
    - [5.1 素数产生程序：一个简单的重构示例](#51-素数产生程序一个简单的重构示例)
  - [第 6 章 一次编程实践](#第-6-章-一次编程实践)
- [第Ⅱ部分 敏捷设计](#第ⅱ部分-敏捷设计)
  - [第 8 章 单一职责原则（SRP）](#第-8-章-单一职责原则srp)
    - [8.1 单一职责原则](#81-单一职责原则)
    - [8.1 定义职责](#81-定义职责)
    - [8.2 分离耦合的职责](#82-分离耦合的职责)
    - [8.3 持久化](#83-持久化)
    - [8.4 结论](#84-结论)
  - [第 15 章 状态图](#第-15-章-状态图)
    - [15.1 基础知识](#151-基础知识)
      - [15.1.1 特定事件](#1511-特定事件)
      - [15.1.2 超状态](#1512-超状态)
      - [15.1.3 初始伪状态和结束伪状态](#1513-初始伪状态和结束伪状态)
    - [15.2 使用 FSM 图示](#152-使用-fsm-图示)
    - [15.3 结论](#153-结论)
  - [第 17 章 用例](#第-17-章-用例)
    - [17.1 编写用例](#171-编写用例)
      - [17.1.1 备选流程](#1711-备选流程)
      - [17.1.2 其他东西呢](#1712-其他东西呢)
    - [17.2 结论](#172-结论)
- [第 Ⅲ 部分 薪水支付案例研究](#第-ⅲ-部分-薪水支付案例研究)
- [第 Ⅳ 部分 打包薪水支付系统](#第-ⅳ-部分-打包薪水支付系统)
- [第 Ⅴ 部分 气象站案例研究](#第-ⅴ-部分-气象站案例研究)
- [第 Ⅵ 部分 ETS 案例研究](#第-ⅵ-部分-ets-案例研究)

# 前言

**Bob 的导言**

离 Claudia 说出这句合情合理的抱怨，已经 7 年了，不过我觉得我已经做出了补偿。在这几年里，我出版了 3 本书，对于一个同时经营着一家咨询公司，并且还得进行大量的代码编写、培训、指导、演讲的工作，以及撰写文章、专栏和博客的人来讲，要每隔一年出一本书是一项很大的挑战，更不要说还得养活并陪伴一个大家庭了。但是，我喜欢这样。

敏捷开发（Agile Development）就是指能够再需求迅速变化的情况下快速开发软件。为了达到这种敏捷性，我们需要使用一些实践提供必要的准则和反馈，需要使用一些设计原则使我们的软件保持灵活且可维护，还需要理解一些已经被证明在特定问题中可以权衡这些原则的设计模式。本书试图将所有这 3 个概念融汇起来，使他们成为有机的整体。

本书首先描述了这些原则、模式以及实践，然后通过许多案例来演示如何应用它们。更重要的是，案例给出的并不是最终的结果，而是设计的过程。你会看到设计者犯错误；你会看到他们如何找到错误并最终改正；你会看到他们对问题苦思冥想，面对一些难以权衡的含糊问题的疑惑与探索。是的，你会看到设计的真正历程。

**Micah 的导言**

2005 年初，我参与到一个小的开发团队中，该团队正准备用 C# 开发一个 .NET 应用程序。使用敏捷开发实践的强制性规定，这也是我参与其中的原因之一。虽然我以前曾经使用过 C#，但是我的大部分编程经验都是基于 Java 和 C++ 的。我认为 .NET 不会有什么不同，结果也表明确实如此。

项目开始两个月后，我们进行了第一次发布。这是一次部分发布，其中包含了所有计划特性中的一部分，但却是完全可用的，并且也确实被投入使用。仅仅两个月后，公司就得到了我们开发的软件带来的好处。管理层非常兴奋，他们要求雇佣更多的人，这样就可用启动更多的项目。

我投身到敏捷社区已经有几年了，我认识很多可以帮助我们的敏捷开发者。我通知了他们每一个人，请求他们加入到我们中来。结果，没有一个敏捷朋友加入我们的团队。为什么？也许最主要的原因是因为我们是基于 .NET 进行开发的。

几乎所有敏捷开发者都具有 Java、C++ 或者 Smalltalk 方面的背景。几乎从来没有听说过有敏捷 .NET 程序员。也许，当我说我们正在使用 .NET 进行敏捷软件开发时，我的那些朋友根本就没当回事，也许他们想避免和 .NET 有什么瓜葛。这是一个严重的问题。我已经不止一次看到这种情况了。

我讲过许多为期一周的关于各种软件主题的课程，有机会见到来自世界各地具有广泛代表性的开发者。我曾经指导过的很多学生都是 .NET 程序员，也有很多是 Java 和 C++ 程序员。恕我直言：在我的经历中，.NET 程序员常常要比 Java 和 C++ 程序员差一些。显然，也并非总是如此。但是，通过在课堂中的再三观察，我只能得出这样的结论：在敏捷软件实践、设计模式、设计原则等方面，.NET 程序员往往要弱一些。在我的课堂上，.NET 程序员常常从来没有听说过这些基本概念。必须改变这种情况。

本书的另一版本，由我父亲 Robert C.Martin 撰写的 Agile Software Development: Principles, Patterns, and Practices 在 2002 年末出版，并赢得了 2003 年的 Jolt 大奖。那是一本很好的书，得到了许多开发者的赞扬。遗憾的是，它对 .NET 社区几乎没有提供什么帮助。尽管书中的内容同样适用于 .NET，但是几乎没有 .NET 程序员读过它。

我希望这本书 .NET 版本能够充当 .NET 社区和其他开发者社区之间的桥梁。我希望程序员能够阅读它并看到更好的的构建软件的方法。我希望他们开始使用更好的软件实践、创建更好的设计并提升 .NET 应用的质量标准。我希望 .NET 程序员可以和其他程序员一样好。我希望 .NET 程序员能够在软件社区中获得新的地位，这样 Java 程序员就会以加入 .NET 团队为荣。

在完成本书的整个过程中，对于是否把我的名字放在一本与 .NET 有关的图书的封面上，我做过多次思想斗争。我曾问自己是否要把名字和 .NET 联系在一起，并承担可能由此带来的所有负面后果，但现在我不再迟疑了。我是一名 .NET 程序员。不！是一名敏捷的 .NET 程序员。我以此为荣。

**关于本书**

*本书简史*

20 世纪 90 年代初，我（Bob）写了一本名为 Designing Object-Oriented C++ Application using the Booch Method 的书。它曾是我的代表作，其效果和销量都让我非常高兴。

这本书最初想作为 Designing 一书的第 2 版，但是结果并非如此。书中保留的原书内容非常少，只有 3 章内容，即使这 3 章也进行了大量的修改，但书的意图、精神以及许多知识是相同的。自 Designing 初版 10 年以来，在软件设计和开发方面我又学到了非常多的知识，这些将在本书中表现出来。

十年过去了！Designing 刚好在因特网大爆炸之前出版。从那时起，我们使用的缩略词的数量已经翻了一倍，诸如 EJB、RMI、J2EE、XML、XSLT、HTML、ASP、JSP、ZOPE、SOAP、C#、.NET 以及设计模式、Java、Servelet 和应用服务器。我要告诉你，要使这本书的内容跟得上最新技术潮流非常困难。

*与 Booch 的关系*

1997 年，Booch 与我联系，让我帮他撰写其非常成功的 Object-Oriented Analysis and Design with Applications 一书的第 3 版。以前，我和他在一些项目中有过合作，并且是他的许多作品（包括 UML）的热心读者和参编者。因此，我高兴地接受了，并邀请我地好朋友 Jim Newkirk 来帮助完成这项工作。

在接下来地两年中，我和 Jim 为 Booch 的书撰写了许多章节。当然，这些工作意味着我不可能按照我本来想的那样投入大量精力写作本书，但是我觉得 Booch 的书值得我这样做。另外，当时这本书完全只是 Designing 的第 2 版，并且我的心思也不在其上。如果我要讲些东西的话，我想讲新的并且是不同的东西。

不幸的是，Booch 著作的这个版本始终没有完成。在正常情况下已经很难抽出空来写书了，在浮躁的 .com 泡沫时期，就更加不可能了。Grady 忙于 Rational 以及 Catapule 等新公司的事务。因此这项工作就停止了。最后，我问 Grady 和 Addison-Wesley 公司是否可以把我和 Jim 撰写的那些章节包含在本书中，他们很慷慨地同意了。于是，一些案例研究和 UML 的章节就由此而来。

*极限编程的影响*

1998 年后期，极限编程（XP）崭露头角，它有力地冲击了我们所信奉的关于软件开发的观念。我们是应该在编写任何代码前先创建许多 UML 图呢？还是应该不使用任何种类的 UML 图而仅仅编写大量代码？我们是应该编写大量描述我们设计的叙述性文档？还是应该努力使代码具有自释义能力以及表达力，使辅助性的文档不再必要了？我们应该结对编程吗？我们应该在编写产品代码前先编写测试吗？我们应该做什么呢？

这场变革来得正是时候。在 20 世纪 90 年代的中后期，Object Mentor 公司在面向对象设计以及项目管理问题上帮助了许多公司。我们帮助这些公司完成项目，在此过程中，我们慢慢地向这些公司灌输自己的一些观点和做法。遗憾的是，这些观点和做法没有被记录下来，它们只是我们对客户的口述。

到了 1998 年，我认识到需要把我们的过程和实践写下来，这样就可以更好地把它们传达给我们地客户。于是，我在 C++ Report 上撰写了许多关于过程的论文，但这些文章都没有达到目的。它们提供了丰富的信息并且在某些情况下也很引人入胜，但是它们不是对我们在项目中实际应用的实践和看法的整理，而是对影响我数十年的价值挂念的一种不经意的放弃。Kent Beck 向我指出了这一点。

*与 Kent Beck 的关系*

1998 年末，当我正为整理 Object_Mentor 过程烦恼时，我偶然看到了 Kent 在极限编程（XP）方面的一些文字。这些文字散布在 Ward Cunningham 的 wiki 中，并且和其他一些人的文字混合在一起。尽管如此，通过努力和勤奋，我还是抓住了 Kent 所谈论的要点。这激起了我极大的兴趣，但是仍有一些疑虑。XP 中的某些东西和我的开发过程观念完全吻合，但是其他一些东西，比如缺乏明确的设计阶段，却令我迷惑不解。

我和 Kent 来自完全不同的软件环境。他是以恶搞知名的 Smalltalk 顾问，而我却是一个知名的 C++ 顾问。这两个领域之间很难相互交流。这之间几乎有一个库恩式的（Kuhnian）范型隔阂。

在其他情况下，我绝不会邀请 Kent 为 C++ Report 撰写论文。但是我们关于过程认识上的一致填补了语言上的隔阂。1992 年 2 月，我在慕尼黑的 OOP 会议上遇到了 Kent。他在进行关于 XP 的演讲，而我在进行面向对象设计原则的演讲，我们的演讲场所正好面对面。由于无法听到他的演讲，我就在午餐时找到了 Kent。我们谈论了 XP，我邀请他为 C++ Report 撰写一篇论文。这是一篇很棒的论文，其中描述了 Kent 和一位同事在一小时左右的现场系统开发中所进行的彻底的设计改变。

在接下来的几个月中，我逐渐消除了自己对 XP 的担心。我最大的担心在于所采用的过程中没有一个明显的预先设计阶段，我对此有些犹豫。我不是一直在教导我的客户以及整个行业，设计非常重要，应该投入时间吗？

最后我认识到，实际上我自己也并不真正需要这样一个阶段。甚至在我所撰写的所有关于设计、Booch 图和 UML 图的论文以及图书中，总是把带代码作为验证这些图是否有意义的一种方式。在我所有的客户咨询中，我会先花费 1~2 小时帮助他们绘制一些图，然后会使用代码来指导他们考查这些图。我开始明白，虽然 XP 关于设计的措词有点陌生（在库恩式的意义上），但是这些措词背后的实践对我来说却很熟悉。

我关于 XP 的另一个担心相对比较容易解决。我私底下实际上一直是一个结对程序员。XP 使我可以光明正大地和同伴沉醉于一起编程地快乐之中。重构、持续集成以及现场客户对我来说都非常易于接受。它们都非常接近于我先前对客户建议的工作方式。

有一个 XP 实践对我来说是新的发现。当你第一次听到测试驱动开发（TDD）时会觉得它似乎很平常。它只是要在编写任何产品代码前先编写测试用例。编写的所有产品代码都是为了让失败的测试用例通过。对于这种方式编写代码所带来的意义深远的结果，我始料未及。这个实践完全改变了我编写软件的方法，并把它变得更好了。

于是，到 1999 年秋天，我确信 Object Mentor 应该采用 XP 作为自己的过程，并且我应该放弃编写自己过程的愿望。Kent 在表达 XP 的实践和过程方面已经做了一项卓越的工作，相比起来我自己那些不充分的尝试显得苍白无力了。

*.NET*
在几个大公司之间一直在进行着一场战争。这些公司在为了赢得你的忠诚而战。这些公司相信，如果它们拥有了语言，那么它们将拥有程序员以及雇佣这些程序员的公司。

首先打响这场战争的是 Java。Java 是第一个由大公司创造的用来赢得程序员的编程语言。结果取得了极大的成功。Java 确实深深地扎根于软件开发团队中，并成为现代多层 IT 应用开发的事实标准。

对此的还击之一来自 IBM。IBM 通过 Eclipse 开发环境占领了大部分的 Java 市场。另外一个对此的重大阻击来自微软的一些追求完美的精心设计者，他们给我们提供了通用的 .NET 平台和特定的 C# 语言。

令人惊异的是，很难对 Java 和 C# 做出区分。这两个语言在语义上是等同的，并且语法也非常相似，以至于对许多代码片段无法做出辨别。所有在技术创新上的缺乏，微软都通过其在能力上的卓越表现进行了超额的补偿，并赶超上来，赢得胜利。

本书的第一版是使用 Java 和 C++ 作为编程语言进行编写的。本书使用了 C# 和 .NET 平台。不要把这看作是对某一方的支持。我们不会在这场战争中用户某一方。事实上，我认为当几年后一种更好的语言出现并占领了参与交战的公司花费巨大代价赢得的程序员意向份额时，这场战争就会自行结束。

本书的 .NET 版本只是为了能够影响到 .NET 程序员。虽然本书中的原则、模式和实践与语言无关，但是案例研究却与语言相关。正如 .NET 程序员更加乐于阅读 .NET 案例研究一样，Java 程序员则更加乐于阅读 Java 样例。

**仅在细节中**

本书包含了许多 .NET 代码。希望你能够仔细阅读它们，因为在很大程度上，代码正式本书的精髓。代码时本书所讲内容的实际体现。

本书采用重复讲解的方式，由一系列不同规模的案例研究组成。有些案例非常小，有些案例则需要用几章来描述。每个案例研究之前都有一些预备材料，其中讲述了在该案例研究中将用到的面向对象设计原则和模式。

本书首先讨论了开发实践和过程，其中穿插了许多小的案例研究以及示例。然后，我们转移到设计和设计原则的主题上，接着是一些设计模式、更多管理包的设计原则以及更多的模式。所有这些主题都附有案例研究。

因此，请准备好学习一些代码和 UML（统一建模语言）图。你将要学习的图书技术性非常强，其中要教授的知识就像恶魔一样，尽在细节中。

**如何使用本书**

如果你是一名开发人员，请从头至尾阅读本书。本书主要是写给开发人员的，它包含以敏捷方式开发软件所需要的信息。从头至尾阅读可以首先学习实践，接着是原则，然后是模式，最后是把它们全部联系起来的案例研究。把所有这些知识整合起来会帮助你完成项目。

如果你是一名管理人员或者业务分析师，请阅读第一部分“敏捷开发”。第 1~6 章提供了对敏捷原则和实践的深入讨论。内容涉及需求、计划、测试、重构以及编程。它会给你一些有关如何构建团队以及管理项目的指导，帮助你完成项目。

如果你想学习 UML，请首先阅读第 13~19 章。然后，阅读第三部分 “薪水支付案例研究” 的所有章节。这种阅读方法在 UML 语法和使用方面会给你提供一个好的基础，同时也会帮助你在 UML 和 C# 语言之间进行转换。

如果你想学习设计模式，请先阅读第二部分 “敏捷设计”学习设计原则，然后阅读第三部分 “ 薪水支付案例研究”、第四部分 “打包薪水支付系统”。这几部分定义了所有的模式，并且展示了如何在典型的情形中使用它们。

如果你想学习面向对象设计原则，请阅读第二部分 “敏捷设计”学习设计原则，然后阅读第三部分 “ 薪水支付案例研究”以及第四部分 “打包薪水支付系统”。这些章节将会描述面向对象设计的原则，并且向你展示如何使用这些原则。

如果你想学习敏捷开发方法，请阅读第一部分“敏捷开发”。这部分描述了敏捷开发，内容涉及需求、计划、测试、重构以及编程。

# 第Ⅰ部分 敏捷开发

*人与人之间的交互是复杂的，并且其效果从来都难以预期，但是它们却是工作中最为重要的方面。*

原则、模式和实践都是重要的，但是使它们发挥作用的是人。正如 Alistair Cockburn 所说的：“过程和技术对于项目的结果只有次要的影响。首要的影响是人。”

如果把程序员团队看作是由过程驱动的组件所组成的系统，那么就无法对他们进行管理。用 Alistair Cockburn 的话来说，人不是“插入即兼容的编程装置。”如果想要项目取得成功，我们就必须构建起具有合作精神的、自组织的团队。

鼓励构建这种团队的公司比认为软件开发组织不过是由无关紧要的、雷同的一群人堆砌起来的公司更具竞争优势。凝聚在一起的软件团队是最强大的软件开发力量。

## 第 1 章 敏捷实践

*教堂尖顶上的风标，即使由钢铁制成，如果不懂得顺应风势的艺术，一样会很快被暴风所摧毁。*

许多人都经历过由于没有实践的指导而导致的项目噩梦。缺乏有效的实践会导致不可预测性、重复的错误以及努力的白白浪费。延期的进度、增长的预算和低劣的质量致使客户对我们丧失信心。更长时间的工作却生产出更加低劣的软件产品，也使得开发人员感到沮丧。

一旦经历了这样的惨败，就会害怕重蹈覆辙。这种恐惧激发我们创建一个过程来约束我们的活动，并要求某些输出和制品。我们根据过去的经验来规定这些约束和输出，挑选那些在以前的项目中看起来好像工作得不错得方法。我们希望这些方法这次还会有效，从而消除我们的恐惧。

然而，项目并没有简单到使用一些约束和制品就能可靠地防止错误的地步。当连续地犯错误时，我们会对错误进行诊断，并在过程中增加更多的约束和制品来防止以后重犯这样的错误。经过多个项目以后，我们就会不堪巨大、笨重的过程的重负，极大地削弱我们完成项目的能力。

一个大而笨重的过程会产生它本来企图去避免的问题。它降低了团队的开发效率，使得进度延期，预算超支。它降低了团队的响应能力，使得团队经常创建错误的产品。遗憾的是，这导致许多团队认为，这种结果是因为他们没有采用足够的过程方法引起的。因此，在这种失控的过程膨胀中，过程会变得越来越庞大。

用失控的过程膨胀来描述公元 2000 年前后许多软件公司中的情形是很合适的。虽然有很多团队在工作中并没有使用过程方法，但是采用庞大、重型的过程方法的趋势在迅速增长，在大公司中尤其如此。

### 1.1 敏捷联盟

2001 年初，由于看到许多公司的软件团队陷入了不断增长的过程的泥潭，一批业界专家聚集在一起概括出了一些可以让软件开发团队具有快速工作和响应变化能力的价值观和原则。他们称自己为敏捷联盟。在随后的几个月中，我们创建出了一份价值观声明，也就是敏捷联盟宣言。

```
敏捷软件开发宣言
我们正在通过亲身实践以及帮助他们实践，揭示更好软件开发方法。通过这项工作，我们认为：

人和交互          重于    过程和工具
可以工作的软件    重于    面面俱到的文档
客户合作          重于    合同谈判
随时应对变化      重于    遵循计划

虽然右项也有其价值，但我们认为左项更加重要。
```

#### 1.1.1 人和交互重于过程和工具

人是获得成功的最为重要的因素。如果团队中没有优秀的成员，那么就算是使用好的过程也不能从失败中挽救项目，但是，不好的过程却可以使最优秀的团队成员失去效用。如果不能作为一个团队进行工作，那么即使拥有一批优秀的成员也一样会惨败。

一个优秀的团队成员未必就是一个一流的程序员。一个优秀的团队成员可能是一个具有平均水平的程序员，但是却能够很好地与他人合作。好的合作（沟通以及交互）能力要比单纯的编程能力更为重要。一个由平均水平的、具有良好沟通能力的程序员组成的团队，将要比那些虽然拥有一批高水平的程序员，但是成员之间却不能进行交流的团队更有可能获得成功。

合适的工具对于成功来说非常重要。像编译器、IDE和源代码控制系统等，对于团队的开发者正确地完成他们的工作至关重要。然而，工具的作用可能会被过分地夸大。使用过多庞大、笨重的工具就像缺少工具一样，都是不好的。

我的建议是从使用小工具开始。尝试一个工具，直到发现它无法使用时才去更换它。不要急着去购买那些先进的、价格昂贵的源代码控制系统，相反应该先使用一个免费的系统，直到能够证明该系统已经不再适用。在决定为团队购买最好的 CASE 工具许可证前，先使用白板和方格纸，直到明确地直到需要更多的功能。在决定使用庞大的、高性能的数据库系统前，先使用平面文件。不要认为更大的、更好的工具可以自动地帮你做得更好。通常，它们造成的障碍要大于带来的帮助。

记住，团队的构建要比环境的构建重要得多。许多团队和管理者就犯了先构建环境，然后期望团队自动凝聚在一起的错误。相反，应该首先致力于构建团队，然后再让团队基于需要来配置环境。

#### 1.1.2 可以工作的软件重于面面俱到的文档

没有文档的软件是一种灾难。代码不是交流系统原理和结构的理想媒介。团队更需要编制易于阅读的文档，来对系统及其设计决策的依据进行描述。

然而，过多的文档比过少的文档更糟。编制众多的文档需要花费大量的时间，并且使这些文档和代码保持同步，要花费更多的时间。如果文档和代码之间失去同步，那么文档就会变成庞大的、复杂的谎言，会造成重大的误导。

对于团队来说，编写并维护一份系统原理和结构方面的文档总是一个好主意，但是那份文档应该短小并且主题突出。短小的意思是说，最多有一二十页。主题突出的意思是说，应该仅论述系统的最高层结构和概括的设计原理。

如果我们拥有的仅仅是一份简短的系统原理和结构方面的文档，那么如何来培训新的团队成员，使他们能够从事系统相关的工作呢？我们会非常密切地和他们工作在一起。我们紧挨着他们坐下来帮助他们，把我们地知识传授给他们。我们通过密切的培训和交互使他们成为团队的一部分。

在向新的团队成员传授知识方面，最好的两份文档是代码和团队。代码真实地表达了它所作的事情。虽然从代码中提取系统的原理和结构信息可能是困难的，但是代码是唯一没有二义性的信息源。在团队成员的头脑中，保存着时常变化的系统的脉络图。人和人之间的交互是把这份脉络图记在纸上并传授给他人的最快、最有效的方式。

许多团队因为注重文档而非软件，从而导致进度拖延。这常常是一个致命的缺陷。有一个简单规则可以预防该缺陷的发生。

```
Martin 文档第一定律：直到迫切需要并且意义重大时，才编制文档。
```

#### 1.1.3 客户合作重于合同谈判

不能像订购日用品一样来订购软件。你不能够仅仅写下一份关于你想要的软件的描述，然后就让人在固定的时间内以固定的价格去开发它。所有用这种方式来对待软件的项目的尝试都将以失败告终。有时，失败是惨重的。

告诉开发团队想要的东西，然后期望开发团队消失一段时间回来后就能够交付一个满足需求的系统，这对于公司的管理者来说是具有诱惑力的。然而，这种操作模式将导致低劣的质量和失败。

成功的项目需要定期且频繁的客户反馈。不是依赖于合同或者关于工作的陈述，而是让软件的客户和开发团队密切地工作在一起，并尽量经常地提供反馈。

一个指明了需求、进度以及项目成本的合同存在根本上的缺陷。在大多数情况下，合同中规定的条款远在项目完成之前（有时甚至是远在合同签署之前）就变得没有意义。那些为开发团队和客户的协同工作方式提供指导的合同才是最好的合同。

我在 1994 年为一个大型、需要多年才能完成并有 50 万行代码的项目达成的合同，可以作为一个成功合同的样例。作为开发团队的我们，每个月的报酬相对是比较低的。大部分的报酬要在我们交付了某些大的功能模块后才支付。那些功能模块没有在合同中详细地指明。合同中仅仅规定在一个功能模块通过了客户的验收测试时才支付该功能块的报酬。那些验收测试的细节并没有在合同中指明。

在这个项目开发期间，我们和客户紧密地工作在一起。几乎每个周五，我们都会把软件提交给客户。到下一周的周一或周二，客户会给我们一份关于软件的变更列表。我们会把这些变更放在一起排定优先级，然后把它们安排在随后几周的工作中。客户和我们如此紧密地工作在一起，以至于验收测试根本就不是问题。因为它们周复一周地观察着每个功能模块的演进，所以他们指导何时这个功能块能够满足他们的需要。

这个项目的需求基本处于一个持续变化的状态。大的变更是很平常的。在这期间，也会出现整个功能块被去掉，而另外的功能块被加进来的情况。然而，合同和项目都经受住了这些变更，并获得成功。成功的关键在于与客户的紧密协作，并且合同指导了这种协作，而不是试图去规定项目范围的细节和固定成本下的进度。

#### 1.1.4 随时应对变化重于遵循计划

随时应对变化的能力常常决定着一个软件项目的成败。当我们构建计划时，应该确保计划是灵活的，并且易于适应商务和技术方面的变化。

计划不能考虑得过远。首先，商务环境很可能会变化，这会引起需求的变动。其次，一旦客户看到系统开始运作，他们很可能会改变需求。最后，即使我们知道需求是什么，并且确信他它们不会改变，我们仍然不能很好地估算出开发它们需要的时间。

对于一个缺乏经验的管理者来说，创建一张优美的、关于整个项目的 PERT 或者 Gantt 图，并把它贴到墙上是很有诱惑力的。他们也许觉得这张图赋予了他们对项目的控制权。他们能够跟踪单个人的任务，并在任务完成时将任务从图上去除。他们可以将实际完成的日期和计划完成的日期进行比较，并对出现的任何偏差做出反应。

然而，实际会发生的是：这张图的组织结构不再适用。当团队增加了对系统的认识，当客户增加了对需求的认识，图中的某些任务会变得没有必要。另外一些任务会被发现并增加到图中。简而言之，计划图形状将会改变，而不仅仅是日期上的改变。

较好的做计划的策略是：为一下周做详细计划，为下 3 个月做组略的计划，再以后就做极为简略的计划。我们应该清楚地知道下周要完成的任务，粗略地了解一下以后 3 个月要实现的需求。至于系统一年后将要做什么，有一个模糊的想法就行了。

计划中这种逐渐降低的细致度，意味着我们仅仅对于迫切的任务才花费时间进行详细的计划。一旦制定了这个详细的计划，就很难进行改变，因为团队会根据这个计划启动工作并有了相应的投入。然而，由于该计划仅仅支配了一周的时间，计划的其余部分仍然保持着灵活性。

### 1.2 原则

从上述的价值观中引出了下面的 12 条原则，它们是敏捷实践区别于重型过程的特征所在。

（1）我们最先要做的是通过尽早地、持续地交付有价值地软件来使客户满意。《MIT Sloan 管理评论》杂志刊登过一篇论文，分析了对于公司构建高质量产品方面有帮助的软件开发实践。该论文发现了很多对于最终系统质量有重要影响的实践。其中一个实践表明，尽早交付具有部分功能的系统和系统质量之间具有很强的相关性。改论文指出，初期交付的系统中所包含的功能越少，最终交付的系统的质量就越高。该论文的另一项发现是，以逐渐增加功能的方式经常性地交付系统和最终质量之间有非常强的相关性。交付得越频繁，最终产品的质量就越高。

敏捷实践会尽早地、经常地进行交付。我们努力在项目刚开始的几周内就交付一个具有基本功能的系统。然后，我们努力坚持每几周就交付一个功能渐增的系统。如果客户认为目前的功能已经足够了，客户可以选择把这些系统加入到产品中。或者，他们可以只是选择再检查一遍已有的功能，并指出他们想要做的改变。

（2）我们欢迎需求的变化，即使到了开发后期。敏捷过程能够驾驭变化，为客户创造竞争优势。这是一个关于态度的声明。敏捷过程的参与者不惧怕变化。他们认为改变需求是好事情，因为那些改变意味着团队已经学到了更多如何满足客户需要的知识。

敏捷团队非非常努力地保持软件结构地灵活性，这样当需求变化时，对于系统造成的影响是最小的。在本书的后面部分，我们会学习一些面向对象设计的原则、模式和实践，这些内容会帮助我们维持这种灵活性。

（3）经常交付可以工作的软件，从几个星期到几个月，时间间隔越短越好。我们交付可以工作的软件，并且尽早地、经常性地交付它。我们不赞成交付大量地文档或者计划。我们认为那些不是真正要交付地东西。我们关注的目标是交付满足客户需要的软件。

（4）在整个项目开发期间，业务人员和开发人员必须朝夕工作在一起。为了能够以敏捷的方式进行项目开发，客户、开发人员以及利益相关者之间就必须进行有意义的、频繁的交互。软件项目不像发射出去就能够自动导航的武器，必须要对软件项目持续不断地进行引导。

（5）围绕斗志高昂地人构建项目。给他们提供所需的环境和支持，并且信任他们能够完成工作。人是项目取得成功的最重要的因素。所有其他的因素（过程、环境、管理等）都被认为是次要的，当它们对人有负面的影响时，就要对它们进行改变。

（6）在团队内部，最有效率也最有效果的信息传达方式，就是面对面的交谈。在敏捷项目中，人们之间相互进行交谈。首要的沟通方式就是人与人之间的交互。书面文档会按照和软件一样的时间安排进行编写和更新，但是仅在需要时才这样做。

（7）可以工作的软件是进度主要的度量标准。敏捷项目通过度量当前满足客户需求的软件量来度量开发进度。他们不是根据所处的开发姐u但、已经编写的文档总量或者已经创建的基础设施代码的数量来度量开发进度。仅当 30% 的必需功能可以工作时，才可以确定进度完成了 30%。

（8）敏捷过程提倡可持续开发。出资人、开发者和用户应该总是保持稳定的开发速度。敏捷项目不是 50m 短跑；而是马拉松长跑。团队不是以全速启动并试图在项目开发期间维持那个速度；相反，他们以快速但是可持续的速度行进。

跑得过快会导致团队精力耗尽、抄捷径以致崩溃。敏捷团队会测量他们自己的速度。他们不允许自己过于疲惫。他们不会借用明天的精力来在今天多完成一点工作。他们工作在一个可以保证在整个项目开发期间保持最高质量标准的速度上。

（9）对卓越技术和良好设计的不断追求有助于提高敏捷性。高的产品质量是获取高的开发速度的关键。保持软件尽可能干净、健壮是快速开发软件的途径。因而，所有的敏捷团队成员都致力于只编写他们能够编写的最高质量的代码。他们不会制造混乱然后告诉自己等有更多的时间时再来清理它们。如果他们在今天制造了混乱，就会在今天把混乱清理干净。

（10）简单——尽量减少工作量的艺术是至关重要的。敏捷团队不会试图去构建那些华而不实的系统，他们总是更愿意采用和目标一致的最简单的方法。他们并不看重对于明天会出现的问题的预测，也不会在今天就对那些问题进行防卫。相反，他们在今天以最高的质量完成最简单的工作，并深信如果在明天发生了问题，也会很容易进行处理。

（11）最好的构架、需求和设计都源自自我组织的团队。责任不是从外部分配给单个团队成员，而是分配给整个团队，然后再由团队来确定履行职责的最好方法。

敏捷团队的成员共同来解决项目中所有方面的问题。每一个成员都具有项目中所有方面的参与权力。不存在某个团队成员仅对系统架构、需求或者测试负责的情况。整个团队共同承担那些职责，每一个团队成员都能够影响它们。

（12）每隔一定时间，团队都要总结如何更有效率，然后相应地调整自己的行为。敏捷团队会不断地对团队的组织方式、规则、约定和关系等进行调整。敏捷团队知道团队所处的环境在不断地变化，并且知道为了保持团队的敏捷性，就必须要随环境一起变化。

### 1.3 结论

每一个软件开发人员、每一个开发团队的职业目标，都是给他们的雇主和客户交付最大可能的价值。可是，我们的项目以令人沮丧的速度失败，或者未能交付任何价值。虽然在项目中采用过程方法是出于好意，但是膨胀的过程方法对于我们的失败至少是应该负一些责任的。敏捷软件开发的原则和价值观构成了一个可以帮助团队打破过程膨胀循环的方法，这个方法关注的是可以达到团队目标的一些简单的技术。

在撰写本书的时候，已经有许多的敏捷过程可供选择。包括：SCRUM、Crystal、特征驱动软件开发（Feature-Driven Development，FDD）、自适应软件开发（Adaptive Software Development，ADP）以及极限编程（eXtreme Programming，XP）。不过，绝大多数成功的敏捷团队都是从所有这些过程方法中吸取知识并调和成最适合自己的方法。常见的做法是把 SCRUM 和 XP 结合起来，其中使用 SCRUM 实践来管理多个使用 XP 实践的团队。

## 第 2 章 极限编程概述

**作为开发人员，我们应该记住，XP 并非惟一选择**

在上一章中，我们简要介绍了有关敏捷软件开发方法方面的内容，但它没有确切地告诉我们去做些什么；其中给出了一些泛泛地陈述和目标，却没有给出实际的直到方法。本章要改变这种状况。

### 2.1 极限编程实践

极限编程（eXtreme Programming，简称 XP）是敏捷方法中最著名的一个。它由一系列简单却相互依赖的实践组成。这些实践结合在一起形成了一个胜于部分结合的整体。本章我们将简要地探讨一下这个整体，在后续地章节中，会对一些单独地实践进行研究。

#### 2.1.1 完整团队

我们希望客户、管理者和开发人员紧密地工作在一起，以便于彼此知晓对方所面临地问题，并共同去解决这些问题。谁是客户？XP 团队中的客户是指定义产品的特性并排列这些特性优先级的人或团体。有时，客户是和开发人员同属一家公司的一组业务分析师或者市场专家。有时，客户是用户团体委派的用户代表。有时，客户事实上是支付开发费用的人。但是在 XP 项目中，无论谁是客户，他们都是能够和团队一起工作的团队成员。

最好的情况是客户和开发人员在同一个房间中工作，次一点的情况是客户和开发人员之间的工作距离在 100 米以内。距离越大，客户就约难成为真正的团队成员。如果客户工作在另外一幢建筑或另外一个州，那么他将很难融合到团队中来。

如果确实无法和客户在一起工作，该怎么办呢？我的建议是去寻找能够在一起工作、愿意并能够代替真正客户的人。

#### 2.1.2 用户故事

为了进行项目计划，必须要了解需求，但是却无需了解得太多。对于做计划而言，了解需求只需要做到能够估算它的程度就足够了。你可能认为，为了对需求进行估算，就必须要了解该需求的所有细节。其实并非如此。你必须知道存在很多的细节，也必须知道细节的大致分类，但是你不必知道特定的细节。

需求的特定细节很可能会随时间而改变，一旦客户开始看到集成到一起的系统，就更会如此。看到新系统的问世是关注需求的最好时刻。因此，不要去捕获某个在很长一段时间之后才会实现的需求的特定细节，否则很可能会导致无用功以及对需求不成熟的关注。

在 XP 中，我们和客户反复讨论，以获取对于需求细节的理解，但是不去记录那些细节。我们更愿意客户在索引卡片上写下一些共识的言语，这些只言片语可以提醒我们记起这次交谈。基本上在客户进行书写的同一时刻，开发人员在该卡片上写下对应于卡片上需求的估算。估算是基于在和客户进行交谈期间所得到的对于细节的理解进行的。

用户故事就是正在进行的关于需求的谈话的助记符。它是一个计划工具，客户可以使用它并根据需求的优先级和估算代价来安排实现该需求的时间。

#### 2.1.3 短交付周期

XP 项目每两周交付一次可以工作的软件。每两周的迭代都实现了利益相关者的一些需求。在每次迭代结束时，会给利益相关者演示迭代生成的系统，以得到他们的反馈。

*迭代计划*

每次迭代通常耗时两周。迭代是一次较小的交付，可能会被加入到产品中，也可能不会。迭代计划由一组用户故事组成，这些用户故事是客户根据开发人员确定的预算选出来的。

开发人员通过度量在以前的迭代中所完成的工作量来为本次迭代设定预算。只要估算成本的总量不超过预算，客户就可以为本次迭代选择任意数量的用户故事。

一旦迭代开始，客户就同意不再修改当次迭代中用户故事的定义和优先级别。迭代期间，开发人员可以自由地将用户故事分解成任务，并依据最具技术和商务意义的顺序来开发这些任务。

*发布计划*

XP 团队通常会创建一个发布计划来规划出随后大约 6 次迭代的内容。这就是所谓的发布计划。一次发布通常需要 3 个月的工作。它表示了一次较大的交付，通常此次交付会被加入到产品中。发布计划是由客户根据开发人员给出的预算所选择的、排好优先级别的一组用户故事组成。

开发人员通过度量在以前的发布中所完成的工作量来为本次发布设定预算。只要估算成本的总量不超过预算，客户就可以为本次发布选择任意数量的用户故事。客户同样可以决定在本次发布中用户故事的实现顺序。如果开发团队强烈要求的话，客户可以通过指明哪些用户故事应该在哪次迭代中完成的方式，制订出发布中最初几次迭代的内容。

发布计划不是一成不变的。客户可以随时改变发布的内容。他可以取消用户故事，编写新的用户故事，或者改变用户故事的优先级别。但是，客户应该尽量不去更改一次迭代。

#### 2.1.4 验收测试

可以以客户指定的验收测试的形式来记录有关用户故事的细节。用户故事的验收测试是在就要实现该用户故事之前，或者在实现该用户故事的同时才开始编写的。验收测试使用脚本语言编写，这样它们可以自动、反复地运行。这些测试共同来验证系统是否按照客户指定地行为运转。

验收测试是由业务分析师、质量保证专家以及测试人员在迭代期间编写的。编写验收测试使用的语言对于程序员、客户以及业务人员来说都很容易阅读和理解。程序员就是从这些测试中了解他们正在实现的故事的真实工作细节。这些测试成为真正的项目需求文档。验收测试描述了每个特性的所有细节，并用作验证这些特性是否被正确完成的决定性依据。

一旦通过一项验收测试，就将该测试加入到已经通过的验证测试集合中，并决不允许该测试再次失败。这个不断增长的验收测试集合每天会多次运行，每当系统被创建时，都要运行这个验收测试集。如果一项验收测试失败了，那么系统创建就宣告失败。因而，一项需求一旦被实现，就再不会遭受到破坏。系统从一种工作状态迁移到另一种工作状态，期间，系统的不能工作状态时间决不允许超过几个小时。

#### 2.1.5 结对编程

代码都是由结对的程序员使用同一台工作站共同完成的。结对人员中，一个控制键盘并输入代码。另一个观察着输入的代码，寻找着代码中的错误和可以改进的地方。两个人认真地进行着交互。他们都全身心地投入到软件地编写中。

两人频繁呼唤角色。控制键盘的可能累了或者遇到了困难，他的同伴会取得键盘的控制权。在一个小时内，键盘可能在他们之间来回传递好几次。最终生成的代码是由他们两个人共同设计、共同编写的，两人功劳均等。

结对的关系要经常变换。每天至少要改变一次，这样每个程序员在一天中可以在两个不同的结对中工作。在一次迭代期间，每个团队成员应该和所有其他的团队成员在一起工作过，并且他们应该参与了本次迭代中的所涉及的每项工作。

结对编程会极大地促进知识在团队中的传播。仍然会需要一些专业知识，那些需要一定专业知识的任务通常需要合适的专家去完成，但是那些专家几乎将会和团队中的所有其他人结对。这将加快专业知识在团队中的传播。这样，在紧要关头，其他团队成员就能够代替所需要的专家。Williams 和 Nosek 的研究表明，结对非但不会降低编程人员的效率，反而会大大减少缺陷率。

#### 2.1.6 测试驱动开发

第 4 章会详细讨论这个主题。在此，我们仅进行大致的介绍。

编写所有产品代码的目的都是为了使失败的单元测试能够通过。首先编写一个单元测试，由于它要测试的功能还不存在，所以它会运行失败。然后，编写代码使测试通过。

编写测试用例和代码之间的更迭速度是很快的，基本上在几分钟左右。测试用例和代码共同演化，其中测试用例循序渐进地对代码地编写进行指导（参见第 6 章中的例子）。

作为结果，一个非常完整的测试用例集就和代码一起发展起来。程序员可以使用这些测试来检查程序是否正确地工作。如果结对的程序员对代码进行了小的更改，那么他们可以运行测试，以确保更改没有对程序造成任何的破坏。这会非常有利于重构（在本章后面介绍）。

当为了使测试用例通过而编写代码时，那么所编写的代码天生就是可测试的。更重要的使，这样做会强烈地激发你去解除各个模块间的耦合，以便能独立地对它们进行测试。因为，以这种方式编写的代码的设计往往具有更弱的耦合。面向对象设计的原则在进行这种解耦方面具有巨大的帮助作用（参见本书第二部分）。

#### 2.1.7 集体所有权

每一对编程者都具有签出（check out）任何模块并对它进行改进的权力。每个程序员都不会对任何一个特定的模块或技术单独负责。每个人都参与 GUI 方面的工作；每个人都参与中间件方面的工作；每个人都参与数据库方面的工作。任何人都不会比其他人在一个模块或者技术上具有更多的权威。

这并不意味着 XP 不需要专业知识。如果你的专业领域是有关 GUI 的，那么你最有可能去从事 GUI 方面的任务，但是你也将会被邀请去和别人结对从事有关中间件和数据库方面的任务。如果你决定去学习另一门专业知识，那么你可以承担相关的任务，并和能够传授你这方面知识的专家一起工作。你不会被限制在自己的专业领域。

#### 2.1.8 持续集成

程序员每天会多次签入他们的代码并进行集成。规则很简单。第一个签入的只要完成签入就可以了，所有后面的签入的人负责代码的合并工作。

XP 团队使用非阻塞的源代码控制工具。这就意味着程序员可以在任何时候签出任何模块，而不管是否有其他人已经签出了这个模块。当程序员完成了对于模块的修改并把该模块签入时，他必须把他所做的改动和在他面前签入该模块的程序员所作的任何改动进行合并。为了避免合并的时间过长，团队的成员会非常频繁地检查他们的模块。

结对人员会在一项任务上工作一到两个小时。他们创建测试用例和产品代码。在某个适当的间歇点，也许远在这项任务完成之前，他们决定把代码签入回去。他们首先确保所有的测试都能够通过，然后把新的代码集成进当前的代码库中。如果需要，他们会对代码进行合并。如果有必要，他们会和在签入上有冲突的其他程序员协商。一旦集成了他们的更改，他们就构建新的系统。他们运行系统中的每一个测试，包括当前所有有效的验收测试。如果他们破坏了原先可以工作的部分，他们会进行修正。一旦所有的测试都通过了，他们就算完成了此次签入工作。

因而，XP 团队每天会进行多次系统构建。他们会从头开始创建整个系统。如果系统的最终结果是一张 CD，他们就刻录该 CD。如果系统的最终结果是一个可以访问的 Web 站点，他们就安该 Web 站点，或许会把它安装在一个测试服务器上。

#### 2.1.9 可持续的开发速度

软件项目不是全速的短跑，它是马拉松长跑。那些一跃过起跑线就开始尽力狂奔的团队将会在远离终点前就筋疲力尽。为了快速地完成开发，团队必须要以一种可持续的速度前进。团队必须保证旺盛的精力和敏锐的警觉。团队必须要有意识地保持稳定、适中的速度。

XP 的规则不允许团队加班工作。在版本发布前的一个星期是该规则的唯一例外。如果发布目标就在眼前并且能够一蹴而就，则允许加班。

#### 2.1.10 开放的工作空间

团队在一个开放的房间中一起工作。房间中有一些桌子。每张桌子上摆放了两道三台工作站。每台工作站前有两把椅子。墙壁上挂满了状态图表、任务明细表、UML 图，等待。

房间里充满了交谈的嗡嗡声，结对编程的两人坐在互相能够听得到的距离内，每个人都可以得知另一人是否遇到了麻烦，每个人都了解对方的工作状态，程序员们都处在适合于激烈地进行讨论地位置上。

可能有人认为这种环境会分散人的注意力。很容易会让人担心由于持续的噪音和干扰而一事无成。事实上并非如此。而且，密歇根大学的一项研究表明，在“充满积极讨论的屋子”里工作，生产率非但不会降低，反而会成倍地提高。

#### 2.1.11 计划游戏

第 3 章中会详细介绍 XP 的计划游戏。在这里，仅做简要介绍。

计划游戏的本质是划分业务和开发之间的职责。业务人员（也就是客户）决定特性的重要性，开发人员决定实现一个特性所花费的代价。

在每次发布和迭代的开始，开发人员向客户提供一个预算。客户选择那些所需的代价合计起来小于等于该预算的用户故事。开发者所提供的预算是基于他们在最近一次迭代或者发布中所完成的工作量进行的。

依据这些简单的规则，采用短周期迭代和频繁的发布，很快客户和开发人员就会适应项目的开发节奏。客户会了解开发人员的开发速度。基于这种了解，客户能够确定项目会持续多长时间，以及会花费多少成本。

#### 2.1.12 简单设计

XP 团队使他们的设计尽可能的简单、有表达力。此外，他们仅仅关注于计划在本次迭代中要完成的用户故事，而不会考虑那些未来的用户故事。团队更愿意在一次次的迭代中不断地变迁系统的设计，使之对正在实现的用户故事而言始终保持在最优状态。

这意味着 XP 团队的工作可能不会从基础设施开始。他们并不先去选择数据库或者中间件，而是先以最简单的可能方式实现第一批用户故事。只有当出现一个用户故事迫切需要基础设施时，他们才会引入该基础设施。

下面 3 条 XP 指导原则（mantra）可以对开发人员进行指导。

（1）考虑能够工作的最简单的事情。XP 团队总是尽可能寻找能实现当前用户故事的最简单的设计。在实现当前的用户故事时，如果能够使用平面文件，就不去使用数据库；如果能够使用简单的 Socket 连接，就不去使用 ORB 或者 WebService；如果能够不使用线程，就别去使用它。我们尽量考虑用最简单的方法来实现当前的用户故事。然后，选择一种我们能够实际得到的和该简单性最接近的解决方案。

（2）你不需要它。是的，但是我们知道总有一天会需要数据库，会需要 ORB，也总有一天得去支持多用户。所以，我们现在就需要为那些东西做好准备，不是吗？

如果在确实需要基础设施前拒绝引入它，那么会发生什么呢？XP 团队会对此进行认真的考虑。他们开始时假设将不再需要那些基础设施。只有在有证据，或者至少有十分明显的迹象表明现在引入这些基础设施比继续等待更加合算时，团队才会引入这些基础设施。

（3）一次，并且只有一次。极限编程者不能容忍重复的代码。无论在哪里发现重复的代码，他们都会消除这些重复。

导致代码重复的因素有许多。最明显的是通过鼠标选中一段代码，然后四处进行粘贴。当发现那些重复的代码时，我们会通过创建一个函数或基类的方法来消除它们。有时两个或多个算法非常相似，但是它们之间又存在有微秒的差别，我们会把它们变成函数，或者使用 TEMPLATE METHOD 模式（请参见第 22 章）。无论是哪一种代码重复之源，一旦发现，就必须被消除。

消除重复最好的方法就是抽象。毕竟，如果两种事物相似的话，必定存在某种抽象能够统一它们。这样，消除重复的行为会迫使团队提炼出许多的抽象，并进一步减少代码间的耦合。

#### 2.1.13 重构

第 5 章会对重构进行详细的讨论，下面只是一个简单的介绍。

代码往往会腐化。随着我们添加一个又一个的特性，处理一个又一个的错误，代码的结构会逐渐退化。如果对此置之不理的话，这种退化最终会导致纠结不清、难于维护的混乱代码。

XP 团队通过经常性的代码重构来扭转这种退化。重构就是在不改变代码行为的前提下，对其进行一系列小的改造，旨在改进系统结构的实践活动。每个改造都是微不足道的，几乎不值得去做。但是所有的这些改造叠加在一起，就形成了对系统设计和构架显著的改进。

在每次细微改造之后，我们都会运行单元测试以确保改造没有造成任何破坏，然后再去做下一次改造。如此往复，周而复始。通过这种方式，我们可以在改造系统设计的同时，保持系统可以工作。

重构是持续尽心的，而不是在项目结束时、版本发布时、迭代结束时甚至每天快下班时才进行的。重构是我们每隔一个小时或者半小时就要去做的事情。通过重构，我们可以持续地保持代码尽可能干净、简单并且具有表达力。


#### 2.1.14 隐喻

隐喻是唯一一个不具体、不直接的 XP 实践，也是所有 XP 实践中最难理解的一个。极限编程者在本质上都是务实主义者，隐喻这个缺乏具体定义的概念使我们觉得很不舒服。的确，一些 XP 支持者经常讨论把隐喻从 XP 的实践中去除。然而，在某种意义上，隐喻却是 XP 所有实践中最重要的实践之一。

想象一下智力拼图玩具。你怎样知道如何把各个小块拼在一起？显然，每一块都与其他块相邻，并且它的形状必须与相邻的块完美地吻合。如果你眼睛看不见但是具有很好的触觉，那么通过锲而不舍地筛选每个小块，不断地尝试它们的位置，也能够拼出整个图形。

但是，相对于各个小块的形状而言，还有一种更为强大的力量把这些复杂的小块拼装在一起。这既是整张拼图的图案。图案是真正的向导。它的力量是如此之大，以至于如果图案中相邻的两块不具有互相吻合的形状，那么你就可以断定拼图玩具的制作者把玩具做错了。

这就是隐喻。它是将这个系统联系在一起的全局视图。它是系统的愿景，是它使得所有单独模块的位置和外观变得明显直观。如果模块的外观于整个系统的隐喻不符，那么你就知道该模块是错误的。

隐喻通常可以归结为一个名字系统。这些名字提供了一个系统组成元素的词汇表，并且有助于定义它们之间的关系。

例如，我曾经开发过一个以每秒 60 个字符的速度将文本输出到屏幕的系统。以这样的速度，字符充满整个屏幕需要一段时间。所以我们让产生文本的程序把产生的文本放到了一个缓冲区中。当缓冲区满了的时候，我们把该程序交换到磁盘上。当缓冲区快要变空时，我们把该程序交换回来并让它继续运行。

我们用装卸卡车拖运垃圾来比喻整个系统。缓冲区是小卡车。屏幕是垃圾场。程序是垃圾制造者。所有的名字相互吻合，这有助于我们从整体上去考虑系统。

举另一个例子，我曾经开发过一个分析网络流量的系统。每 30 min，系统会轮询几十个网络适配器，并从中获取监控数据。每个网络适配器为我们提供一小块由几个单独变量组成的数据。我们称这些数据块为“面包切片”。这些面包切片是待分析的原始数据。分析程序“烤制”这些切片，因而被称为“烤面包机”。我们把数据块中的单个变量成为“面包屑”。总之，它是一个有用并且有趣的隐喻。

当然，隐喻不仅仅是一个名字系统。隐喻是系统的愿景，它指导着所有开发者去选择合适的名字，把函数放到合适的位置，创建出新的合适的类和方法，等等。

### 2.2 结论

极限编程是一组简单、具体的实践，这些实践结合在一起形成了一个敏捷开发过程。极限编程是一种优良、通用的软件开发方法。对于大多数项目团队来说，可以拿来直接采用，也可以增加一些实践，或者对其中的一些实践进行修改后再采用。


## 第 3 章 计划

**当你能够度量你所说的，并且能够用数字去表达它时，就表示你了解了它；若你不能度量它，不能用数字去表达它，那么说明你的知识就是匮乏的、不能令人满意的。**

下面的内容是对极限编程（XP）中计划游戏（planning game）部分的描述。它和在其他敏捷方法（如 SCRUM、Crystal、Feature-Driven Development，简称 FDD、Adaptive Software Development，简称 ADP）中做计划的方式相似。不过，那些过程方法都没有极限编程对此描述得详细、精确。

### 3.1 初始探索

在项目开始时，开发人员和客户会尽量确定出所有真正的用户故事。然而，他们不会试图去确定所有的用户故事。随着项目的进展，客户会不断编写新的用户故事。素材的编写会一直持续到项目完成。

当识别出一个特性时，会把它分解成一个或者多个用户故事，并把这些用户故事写在索引卡片之类的东西上面。除了用户故事的名字之外，无需记录其他任何内容（比如 Login、Add User、Delete User 或者 Change Password）。此时，我们不会试图记录细节。我们只是希望有某些东西能够提醒我们想起曾经谈论过这些特性。

开发人员共同对这些素材进行估算。估算是相对的，不是绝对的。我们在记录素材的卡片上写上一点“点数”来表示实现这个素材所需要的相对时间。我们可能不能确定一个“点”代表多少时间，但是我们知道实现 8 个点的素材所需要的时间是实现 4 个点的两倍。

*探究、分解和速度*

过大或者多小的素材都是难以估算的。开发人员往往会低估哪些大大的素材而高估那些小的素材。任何过大的素材都应该被分解成小一点的部分，任何过小素材都应该和其他小的素材合并。

例如，考虑下面这个用户素材：“用户能够安全地进行存款、取款、转账活动。” 这是个大的故事。对它进行估算将会很困难，有可能还不准确。然而，我们可以把它分解成以下几个更容易估算的故事：

* 用户可以登录；
* 用户可以退出；
* 用户可以向其账户存款；
* 用户可以从其账户取款；
* 用户可以从其账户向其他账户转账。

在分割或合并一个故事时，应该对其重新进行估算。简单地加上或者减去估算值是不明智的。对用户故事进行分解或者合并完全是为了使其大小适于被准确地估算。当一个估算为 25 点的故事分解为几个点数总和达到 30 点的故事时，不要觉得奇怪！30 点是更精确的估算。

每周，我们都会实现一定数量的故事。这些已经实现了的故事的估算之和是一种度量，称为速度。如果我们在上周实现的故事的点数之和为 42，那么我们的速度就是 42。

3 或 4 周后，我们就会比较了解我们的平均速度。我们可以使用这个平均速度来预测在后面的几周内能完成多少工作。在 XP 项目中，跟踪速度是最为重要的管理手段之一。

在项目开始时，开发人员对他们的速度没有很好的认识。他们必须要给出一个初始的猜测值，在猜测时，可以采用他们感觉会带来最好结果的任何方式进行。此时并不需要非常的准确，所以他们无需在这上面花费过多的时间。事实上，做到和保守的凭直觉猜测一样好就足够了。

### 3.2 发布计划

如果知道了开发速度，客户就能够了解每个故事的成本及其商业价值和优先级别。据此，客户就可以选择那些想要最先完成的故事。这种选择不是单纯依据优先级别进行的。一些重要的但是实现起来代价高昂的故事可能会被推迟实现，而会先去实现一些不那么重要的但是代价要低廉得多的故事。此类选择属于商务决策范畴。由业务人员来决定哪些故事会给他们带来最大利益。

开发人员和客户对项目的首次发布时间达成一致，通常也就是 2~4 个月后的事情。客户挑选在该发布中他们想要实现的故事，并大致确定这些故事的实现顺序。客户必须根据当前的开发速度来选择要实现的故事的数量。由于开发速度开始时并不准确，所以选择也是粗略的。但是此时选择的准确性不是非常重要。当开发速度变得更准确时，可以再对发布计划进行调整。

### 3.3 迭代计划

接着，开发人员和客户决定迭代规模，一般是 1 到 2 周。同样的，客户选择他们想要在首次迭代中实现的故事，但是不能选择于当前开发速度不符的更多的故事。

迭代期间用户故事的实现顺序属于技术决策范畴。开发人员采用最具技术意义的顺序来实现这些故事。他们可以串行地实现，完成了一个再完成下一个；或者他们分摊这些故事，然后一起并行地开发。这完全由开发人员来决定。

一旦迭代开始，客户就不能再改变该迭代期内需要实现地故事。除了开发人员正在实现地故事，客户可以任意改变或重新安排项目中的其他任何故事。

即使没有实现所有的用户故事，迭代也要在先前指定的日期结束。他们会合计所有已经实现的故事的估算值，并计算出本次迭代的开发速度。这个速度会用于计划下一次的迭代。规则很简单：为每次迭代做计划时采用的开发速度就是前一次迭代中测算出来的开发速度。如果团队在最近一次中完成了 31 个故事点，那么他们应该计划在下一次迭代中也完成了 31 个故事点。他们的开发速度是每次迭代 31 个故事点。

这样的速度反馈有助于保持计划与团队实际状况相同步。如果团队在专业知识和工作技能方面有所提高，那么开发速度也会得到相应的提高。如果有人离开了团队，开发速度就会降低。如果系统架构朝有利于开发的方向演化，那么开发速度就会提高。

### 3.4 定义“完成”

除非所有的验收测试都通过，否则就不能说一个故事实现完了。这些验收测试是自动执行的。验收测试是由客户、业务分析师、质量保证专家、测试人员甚至包括程序员，在每个迭代的开始一起编写的。这些测试定义了每个故事的细节，并且是判断故事的行为方式正确与否的决定性依据。在下一章中，我们会更详细地讨论验收测试。

### 3.5 任务计划

在新的迭代开始时，开发人员和客户共同制定计划。开发人员把故事分解成开发任务。一个任务就是一个开发人员能够在 4~16 小时之内实现的一些功能。开发人员在客户的帮助下对这些故事进行分析，并尽可能完全地列举出所有的任务。

可以在活动挂图、白板和其他方便的媒介上列出这些任务。接着，开发人员逐个签订他们想要实现的任务，并以以随意的任务点数对每项任务进行估算。

开发可以签订任务类型的任务。数据库专家并非必须要签订数据库相关的任务。如果愿意，精通 GUI 的人员也可以签订数据库相关的任务。看起来好像无法人尽其能，不过会使用一种方法对这种状况进行管理。这样做的好处是显而易见的：开发人员对整个项目了解得越多，那么团队就会越健康、越有知识。我们希望项目的知识能够传播给每一个团队成员，即使这种知识是和他们的专业无关的。

每个开发人员都知道在上一次的迭代中所完成的任务点数；这个数字就是开发者的预算。没有人会签订超出他们预算的任务点数。

任务的选择一直持续到所有的任务都被分配出去，或者所有的开发人员都已经用完了他们的预算时为止。如果还有任务没有分配出去，那么开发人员会相互协商，基于各自的专长交换相应的任务。如果这样做都不能分配所有任务，那么开发人员就要求客户从本次迭代中去掉一些任务或者故事。如果所有的任务都已经被分配，并且开发人员仍然具有预算空间去完成更多的任务，那么他们会向客户要求更多的故事。

在迭代进行到一半的时候，团队会召开一次会议。在这个时间点上，本次迭代中所安排的半数故事应该被完成。如果没有完成，那么团队会设法重新分配没有完成的任务和职责，以保证在迭代结束时能够完成所有的故事。如果开发人员不能实现这样的重新分派，则需要告知客户。客户可以决定从迭代中去掉一个任务或故事。至少，客户可以指出那些最低优先级别的任务和故事，这样开发人员可以避免在其上花费时间。

例如，假设在本次迭代中客户选择了 8 个故事，总共 24 个故事点。同样假设这些故事分解成 42 个任务。在迭代的中点，我们希望应该完成 21 个任务即 12 个故事点代表的必须是全部完成的故事。我们的目标是要完成故事，而不仅仅是任务。如果在迭代结束的时候，90% 的任务已完成，但没有一个故事是完全完成的，这将是噩梦一般的情景。在迭代的中点，我们希望看到拥有一半故事点数的故事被完成。

### 3.6 迭代

每两周，本次迭代结束，下次迭代开始。在每次迭代结束时，会给客户演示当前可运行的程序。要求客户对项目程序的外观、感觉和性能进行评价。客户会以新用户故事的方式提供反馈。

客户可以经常看到项目的进展。他们可以度量开发速度。他们可以预测团队工作的快慢，并且可以在早期安排实现高优先级别的故事。简而言之，客户拥有按照他们意愿进行管理所需的所有数据和控制权。

### 3.7 跟踪

对于 XP 项目来说，跟踪和管理就是记录每次迭代的结果，然后使用这些结果预测后面几次迭代的内容。请看图 3-1。这幅图称为速度图。通常可以在项目开发房间的墙壁上看到它。这幅图展示了在每周结束时，一共完成了多少故事点（也就是，通过了自动化的验收测试）。虽然周与周之间会有些差异，但是这些数据还是清楚地显示出该团队每周大约完成 42 个故事点。

再请看图 3-2。这幅所谓地余量图（burn-down chart）中展示了每一周过后，还有多少点数需要在下一个主要里程碑或者发布中完成。图中的坡度可以作为预测结束日期的合理依据。

请注意，余量图中表示故事点的柱状图的高度差和速度图中柱状图的高度并不相等。这是因为项目中增加了新的用户故事，也可能暗示着开发人员重新估算了用户故事。

如果在项目开发房间的墙壁上保留这两幅图，那么所有人都可以进行浏览，并且可以在几秒内说出项目的状态。他们可以说出下一个主要里程碑完成的时间，以及范围和估算的偏差程度。这两幅图是 XP 以及所有敏捷方法的真正实质所在。最终都是为了生成可靠的管理信息。

### 3.8 结论

通过一次次的迭代和发布，项目进入了一种可预测、舒适的开发节奏。每个人都知道将要做什么，以及何时去做。利益相关者经常地、实实在在地看到项目的进展。他们看到的不是画满了图、写满了计划的记事本，而是可以接触到、感觉到的可以工作的软件，并且他们还可以对这个软件提供自己的反馈。

开发人员看到的是基于自己估算并且由自己度量的开发速度控制的合理的计划。开发人员选择自己感觉舒适的任务，并保持高的工作质量。

管理人员从每次迭代中获取数据。他们使用这些数据来控制和管理项目。他们不必采用强制、威胁或者恳求开发人员忠心的方式去达到武断的、不切实际的目标。

这听起来好像是美好轻松的，其实不是这样。利益相关者对过程产生的数据并不总是满意的，特别是在刚刚开始时。使用敏捷方法并不意味着利益相关者就可以得到他们想要的。它只不过意味着他们将能够控制团队以最小的代价获得最大的商业价值。

## 第 4 章 测试

**烈火验真金，逆境磨意志。**

编写单元测试是一种验证行为，更是一种设计行为。同样，它更是一种编写文档的行为。编写单元测试避免了相当数量的反馈循环，尤其是功能验证方面的反馈循环。

### 4.1 测试驱动的开发方法

假设我们遵循如下 3 条简单的规则：

* （1）除非已经编写了一个不能通过的单元测试，否则不编写任何产品代码；
* （2）只要编写能够正好导致测试不通过或者编译失败的单元测试就够了，无需再多；
* （3）只要编写能够正好使失败的单元测试通过的产品代码就够了，无需再多。

如果遵循这些规则，我们就是以非常短的迭代周期进行工作。我们仅仅编写刚好不能通过的单元测试，接着编写正好能使得单元测试通过的产品代码。我们以 1min、2min的节奏在这些步骤之间交替。

* 如果我们能够在设计程序前先设计测试方案，情况会怎样？
* 如果我们能够做到：除非缺乏某个功能将导致测试失败，否则就拒绝在程序中实现该功能，情况会怎样？
* 如果我们能做到：除非由于缺少某行代码将导致测试失败，否则就拒绝在程序中增加哪怕一行代码，情况又会怎样？
* 如果首先编写失败的测试表明需要一项功能，然后再逐渐地增加那项功能使测试通过，情况又会怎么样？

这对于我们正在编写的软件的设计有什么影响呢？如果存在这样一组包罗万象的测试，我们能够从中得到什么好处？


第一个也是最明显的一个影响，是程序中的每一项功能都有测试来验证它的操作的正确性。这个测试套件可以给以后的开发提供支援。无论何时我们因疏忽破坏了某些已有的功能，它就会告诉我们。我们可以向程序中增加功能，或者更改程序结构，而不用担心在这个过程中会破坏重要的东西。测试告诉我们程序仍然具有正确的行为。这样，我们就可以更自由地对程序进行改进。

此外，通过首先编写测试，我们就迫使自己把程序设计为可测试的。把程序设计为易于调用和可测试的，是非常重要的。为了成为易于调用和可测试的，程序必须和它的周边环境解耦。这样，首先编写测试迫使我们解除软件中的耦合（forces us to decouple the software)。

首先编写测试的另一个重要效果，是测试可以作为一种无价的文档形式。如果想知道如何调用一个函数或者创建一个对象，会有一个测试展示给你看。测试就像一套范例，它帮助其他程序员了解如何使用代码。这份文档是可编译、可运行的。它保持最新。它不会撒谎。

#### 4.1.1 测试优先设计的示例

最近，我编写了一个名为“Hunt the Wumpus”的程序，仅仅是为了好玩。这是一个简单的冒险类游戏，玩家在洞穴中移动，设法在被 Wumpus 吃掉前杀掉 Wumpus。洞穴是由一系列通过过道互相连接的房间组成。每一个房间可以具有通向东、南、西、北方向的通道。玩家通过告诉计算机要行走的方向而四处移动。

在我为这个程序首先编写的测试中，有一个是程序 4.1 中的 testMove。这个函数创建了一个新的 WumpusGame 对象，通过一个东面的通道把房间 4 连接到房间 5，把玩家放置在房间 4 中，发出了向东移动的命令，接着断言玩家应该在房间 5 中。

**程序 4.1**
```
public void testMove()
{
  WumpusGame g = new WumpusGame();
  g.connect(4,5,"E");
  g.setPlayerRoom(4);
  g.east();
  assertEquals(5, g.getPlayerRoom());
}
```

这段测试代码是在编写 WumpusGame 程序前完成的。我采用了 Ward Cunningham 的建议，按照便于我们自己阅读的方式编写了这个测试。我相信只要按照测试所暗示的结构去编写 WumpusGame 程序，就能够通过测试。这种方法称为有意图的编程（intentional programming）。在实现之前，先在测试中陈述你的意图，使你的意图尽可能地简单、易读。你相信这种简单和清楚会给程序指出一个好的结构。

揭示意图编程（programming by intent）立即引导我产生了一个有趣的决定。测试代码中没有使用 Room 类。把一个房间连接到另一个房间的动作传达了我的意图。看起来，我不需要一个 Room 类来使表达更加容易。相反，我可以仅仅使用整数来表示房间。

这看起来好像不够直观。毕竟，这个游戏在你看来都是关于房间的，在房间之间移动，发现房间中包含的东西，等待。由于缺乏了一个 Room 类，我的意图所暗示的设计就有缺陷了吗？

我可以说在 Wumpus 游戏中，连接（connnection）这个概念要比房间的概念重要得多。我可以说最初的测试指出了一个好的解决问题的方法。的确，我认为事情是这样的，但是那并不是我试图想让大家特别注意的。我想让大家特别注意的是测试在非常早的阶段就为我们阐明了一个重要的设计问题。首先编写测试的行为就是在各种设计决策中进行辨别的行为。

注意，测试告诉了我们程序是如何工作的。我们中的大多数都可以非常容易地根据这个规格说明实现 WumpusGame 的 4 个已经命名了的方法。同样，命名并实现其他 3 个方向的命令也没有什么困难的。如果以后我们想知道如何把两个房间连接起来，或者如何朝一个特定的方向移动，这个测试会直截了当地展示给我们该如何去做。

#### 4.1.2 测试促使模块之间隔离

在编写产品代码之前，先编写测试常常会暴露程序中应该被解耦合地区域。例如，图 4.1 展示了一个薪水支付应用（payroll application）的简单 UML 图。类 Payroll 使用 EmployDatabase 获得 Employee 对象，它要求 Employee 去计算自己的薪水。接着，它把计算结果传递给 CheckWriter 对象产生出一张支票。最后，它在 Employee 对象中记录下支付信息，并把 Employee 对象写回到数据库中。

假定还没有编写任何代码，这个图也是在经历了快速的设计讨论后，刚刚才画在白板上的。现在，需要编写规定 Payroll 对象行为的测试。有许多和编写这些测试相关的问题。首先，要使用什么数据库呢？Payroll 对象需要从若干种类的数据库中读取数据。我们必须要在能够对 Payroll 类进行测试前，编写一个功能完善的数据库吗？我们要把什么数据加载到数据库中呢？其次，我们如何来验证打印出来的支票的正确性？我们无法编写出一个能够观察打印机打印出来的支票并验证上面的数额正确性的自动测试程序来。

使用 MOCK OBJECT 模式可以解决这些问题。我们可以在 Payroll 类以及它的所有协作者之间插入接口，创建实现这些接口的测试桩（test stub）。

图 4.2 展示了这个结构。现在，Payroll 类使用接口和 EmployeeDatabase、CheckWriter以及Employee 进行通信，创建了 3 个实现这些接口的 MOCK OBJECTS。PayrollTest 对象对这些 MOCK OBJECTS 进行查询，来检验 Payroll 对象是否正确地对它们进行了管理。

程序 4.2 展示了测试的意图。测试中创建了合适的 MOCK OBJECTS，把它们传递给 Payroll 对象，告诉 Payroll 对象为所有雇员支付薪水，接着要求 MOCK OBJECTS 去验证所有已开支票的正确性以及所有已记录支付信息的正确性。

当然，这个测试所检查的都是 Payroll 应该使用正确的数据调用正确的函数。它既没有真正地去检查支票的打印，也没有真正地去检查一个真实数据库的正确刷新。相反，它检查了 Payroll 类应该具有与它在独立情况下同样的行为。

你也许想知道为何需要 MockEmployee 类。看起来好像可以直接使用真实的 Employee 类。如果真是那样，我会毫不在乎地使用它。在本例中，我认为对于检查 Payroll 类的功能来说，Employee 类显得复杂了点。

**程序 4.2**
```
public void testPayroll()
{
  MockEmployeeDatabase db = new MockEmployeeDatabase();
  MockCheckWriter w = new MockCheckWriter();
  Payroll p = new Payroll(db, w);
  p.payEmployees();
  assert(w.checksWereWrittenCorrectly());
  assert(db.paymentsWerePostedCorrectly());
}
```

#### 4.1.3 意外获得的解耦合

对于 Payroll 类的解耦合是件好事。这允许我们可以互换使用不同种类的数据库和支票打印机，这种互换能力既是为了测试，也是为了应用的扩展性。我觉得为了进行测试而进行解耦合是有趣的。显然，为了测试而对模块进行隔离的需要，迫使我们以对整个程序结构都有益的方式对程序进行解耦合。在编写代码前先编写测试改善了设计。

本书中的大部分内容是依赖性管理方面的设计原则。这些原则在解耦合和包方面提供了一些指导技术。如果把这些原则作为单元测试策略的一部分来实践它们，就会发现这些原则是非常有用的。正是单元测试在解耦合方面提供了很多的推动和指导。

### 4.2 验收测试

作为验证工具来说，单元测试是必要的，但是不够充分。单元测试用来验证系统的小的组成单元应该按照所期望的方式工作，但是它们没有验证系统作为一个整体时工作的正确性。单元测试是用来验证系统中个别机制的白盒测试（white-box tests）。验收测试是用来验证系统满足客户需求的黑盒测试（black-box tests）。

验收测试由不了解系统内部机制的人编写。客户可以直接或者和一些技术人员（可能是 QA 人员）一起来编写验收测试。验收测试是程序，因此是可以运行的。然而，通常使用专为应用程序的客户创建的脚本语言来编写验收测试。

验收测试是关于一项特性（feature）的最终的文档。一旦客户编写完成了验证一项特性的验收测试，程序员就可以阅读那些验收测试来真正地理解这项特性。所以，正如单元测试作为可编译、运行的有关系统内部结构的文档那样，验收测试是有关系统特性的可编译、执行的文档。

此外，首先编写验收测试的行为对于系统的架构方面具有深远的影响。为了使系统具有可测试性，就必须要在很高的系统架构层面对系统进行解耦合。例如，为了使验收测试无需通过用户界面（UI）就能获得对于业务规则的访问，就必须要比满足这个目的的方式来解除用户界面和业务规则之间的耦合。

在项目迭代的初期，会受到用手工的方式进行验收测试的诱惑。但是，这样做使得在迭代的初期就丧失了由自动化验收测试的需要带来的对系统进行解耦合的促进力，所以是不明智的。当在最早开始迭代时，如果非常清楚地知道必须要自动化验收测试，就会做出非常不同的系统架构方面的权衡。并且，正如单元测试可以促使你在小的方面做出优良的设计决策一样，验收测试可以促使你在大的方面做出优良的系统架构决策。

创建一个验收测试框架看起来是件困难的任务。然而，如果仅仅创建框架中对单个迭代包含的特性进行验收测试所需要的那部分，就会发现并不困难。你还会发现所花费的努力是值得的。

#### 4.2.1 验收测试示例

再次考虑一下薪水支付应用程序。在首次迭代中，必须能够向数据库中增加和删除雇员。必须能够为当前存在数据库中的雇员创建支付薪水的支票。还好，此次只需处理带薪雇员（salaried employees）。其他种类的雇员可以放在后面的迭代中处理。

我们还没有编写任何代码，也没有进行任何设计。这是开始考虑验收测试的最好机会，揭示意图编程再一次成为有用的工具。我们应该以我们认为验收测试应该的样子去编写它们，然后可以构造脚本语言，并根据脚本语言的结构来构造薪水支付系统。

我想使验收测试便于编写并且易于改变。我想把它们放置在一个配置管理工具中，并且把它们保存起来以便于随时可以运行它们。因此，采用简单的文本文件来编写验收测试应该是比较合理的。

下面是一段验收测试脚本的例子：
```
AddEmp  1429 "Robert Martin"  3215.88
Payday
Verify  Paycheck  EmpId 1429  Grosspay  3215.88
```
在这个例子中，我们把雇员号为 1429 的雇员存入数据库。他的名字叫“Robert Martin”，他每月的薪水是 3215.88 美元。接着，我们告诉系统发薪日到了，该给所有的雇员发放薪水了。最后，我们核实产生了一张雇员号为 1429，Grosspay 域的值为 3215.88 的支票。

很明显，客户可以非常容易地编写这种脚本。同样，也非常容易在这种脚本中增加新的功能。然而，我们要考虑一下它所暗示的系统结构。

脚本的头两行针对的是薪水支付应用的功能。

### 4.3 意外获得的架构

请注意验收测试对于薪水支付系统架构的影响。正是优先考虑了测试，才使得我们得到了薪水支付系统的 API 函数。显然，UI 将使用该 API 来完成其功能。同样请注意，支付支票的打印也必须与 CreatePaychecks 函数解耦。这些都是好的架构决策。

### 4.4 结论

测试套件运行起来越简单，就会越频繁地运行它们。测试运行得越多，就会越快地发现和那些测试地任何背离。如果能够一天多次地运行所有的测试，那么系统失效的时间决不会超过几分钟。这是一个合理的目标。我们决不允许系统倒退。一旦它工作在一个确定的级别上，就决不能让它倒退到一个稍低的级别。

然而，验证仅仅是编写测试的好处之一。单元测试和验收测试都是一种文档形式。那样的文档是可以编译和执行的；因此，它是准确和可靠的。此外，编写测试所使用的语言是明确的，并且非常易于观看者阅读。程序员能够阅读单元测试，因为单元测试是使用程序员编程的编程语言编写的。客户能够阅读验收测试，因为验收测试是使用简单的表格式语言编写的。

也许，测试最重要的好处就是它对于架构和设计的影响。为了使一个模块或者应用程序具有可测试性，必须要对它进行解耦合。越是具有可测试性，耦合关系就越弱。全面地考虑验测试和单元测试对软件的结构具有深远的正面影响。


## 第 5 章 重构

**大千世界中，惟一缺乏的就是人类的注意力。**

本章讲述的是关于人的注意力的。阐述人们应该专注于手边的工作并且确信自己正在尽全力，说明了使事物能够工作和使事物正确之间的区别，介绍了我们放入代码结构中的价值。

在 Martin Fowler 的名著《重构》一书中，他把重构（Refactoring）定义为：“...在不改变代码外在行为的前提下对代码做出修改，以改进代码的内部结构的过程。”可是我们为什么要改进已经能够工作的代码的结构呢？不是还有句古老的谚语，“如果它没有坏，就不要去修理它！”吗？

每一个软件模块都具有三项职责。第一个职责是它运行起来所完成的功能。这也是该模块得以存在的原因。第二个职责是它要应对变化。几乎所有的模块在它们的生命周期中都要变化，开发者有责任保证这种改变应该尽可能地简单。一个难以改变的模块是拙劣的，即使能够工作，也需要对它进行修正。第三个职责是要阅读它的人能够理解。对该模块不熟悉的开发人员应该能够比较容易地阅读并理解它。一个无法被理解的模块也是拙劣的，同样需要对它进行修正。

怎样才能让软件模块易于阅读、易于修改呢？本书的主要内容都是关于一些原则和模式的，使用这些原则和模式可以帮助你创建更加灵活和具有适应性的软件模块。然而，要使软件模块易于阅读和修改，所需要的不仅仅是一些原则和模式。还需要你的注意力，需要纪律约束，需要创造美的激情。

### 5.1 素数产生程序：一个简单的重构示例

观察程序 5.1 中所示的代码，这个程序会产生素数。它是一个大函数，其中有辅助阅读的注释和很多单字母变量。

**程序 5-1 GeneratePrimes.cs，版本 1**
```
using System;
public class GeneratePrimes
{
  public static int[] GeneratePrimeNumbers(int maxValue)
  {
    if (maxValue >= 2)
    {
      int s = maxValue + 1;
      bool[] f = new bool[s];
      int i;
      
      for (i = 0; i < s; i++)
      {
        f[i] = true;
      }
      
      f[0] = f[1] = false;
      int j;
      for (i = 2; i < Math.Sqrt(s) + 1; i++)
      {
        if(f[i])
        {
          for (j = 2 * i; j < s; j += i)
          f[j] = false;
        }
      }
      
      int count = 0;
      for (i = 0; i < s; i++)
      {
        if (f[i])
        {
          count++;
        }
      }

      int[] primes = new int[count];
      for (i = 0, j = 0; i < s; i++)
      {
        if (f[i])
        {
          primes[j++] = i;
        }
      }
      return primes;
    }
    else
    {
      return new int[0];
    }
  }
}
```

为 GeneratePrimes 编写的单元测试可以参见程序 5.2。它采用了一种统计学的方法，主要检查产生器能否产生 0、2、3 以及 100 以内的素数。在第一种情况下，应该没有素数；在第二种情况下，应该有一个素数，并且该素数应该是 2；在第三种情况下，应该有两个素数，它们应该是 2 和 3。在最后一种情况下，应该有 25 个素数，其中最后一个是 97。如果所有这些测试都通过了，那么就认为产生器是可以工作的。我怀疑这种做法的可靠性，但是我不能想象出一个合理的情况，在这个情况下这些测试都将通过但是函数却是错误的。

**程序 5.2 GeneratePrimesTest.cs**
```
using NUnit.Framework;
[TestFixture]
public class GeneratePrimesTest
{
  [Test]
  public void TestPrimes()
  {
    int[] nullArray = GeneratePrimes.GeneratePrimeNumbers(0);
    Assert.AreEqual(nullArray.Length, 0);
    int[] minArray = GeneratePrimes.GeneratePrimeNumbers(2);
    Assert.AreEqual(minArray.Length, 1);
    Assert.AreEqual(minArray[0], 2);
    int[] threeArray = GeneratePrimes.GeneratePrimeNumbers(3);
    Assert.AreEqual(threeArray.Length, 2);
    Assert.AreEqual(threeArray[0], 2);
    Assert.AreEqual(threeArray[1], 3);
    int[] centArray = GeneratePrimes.GeneratePrimeNumbers(100);
    Assert.AreEqual(centArray.Length, 25);
    Assert.AreEqual(centArray[24], 97);
  }
}
```

## 第 6 章 一次编程实践

# 第Ⅱ部分 敏捷设计

## 第 8 章 单一职责原则（SRP）

**只有佛自己应当担负起公布玄妙秘密的职责。**

单一职责原则曾经在 Tom Demaro 和 Meilir Page-Jones 的著作中描述过，并称之为内聚性。他们把内聚性定义为：一个模块的组成元素之间的功能相关性。在本文章中，我们稍微改变一下它的含义，把内聚性和引起一个模块或者类改变的作用力联系起来。

### 8.1 单一职责原则

就一个类而言，应该仅有一个引起它变化的原因

考虑第 6 章中保龄球比赛的例子。在开发它的大部分时间内，Game 类一直具有两个不同的职责。一个职责是跟踪当前轮的比赛，另一个职责是计算比赛的得分。最后，RCM和RSK把这两个职责分离到两个类中。Game类保持跟踪每一轮比赛的职责，Scorer类负责计算比赛的得分。

为何要把这两个职责分离到单独的类中呢？因为每一个职责都是一个变化轴线。当需要变化时，该变化会反映为类的职责变化。如果一个类承担了多于一个职责，那么引起它变化的原因就会有多个。

如果一个类承担的职责过多，就等于把这些职责耦合在了一起。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。

例如，考虑图 1 中的设计。Rectangle 类具有两个方法，如果所示。一个方法把矩形绘制在屏幕上，另一个方法计算矩形的面积。

有两个不同的应用程序使用 Rectangle 类。一个应用程序是有关计算几何学方面的，使用 Rectangle 类来处理几何形状的数据运算，但它从来不会在屏幕上绘制矩形。另一个应用程序实质上有关图形绘制方面的，它也可能会进行一些几何运算，但它可能会在屏幕上绘制矩形。

这个设计违反了单一职责原则。Rectangle 类具有两个职责。第一个职责提供了一个矩形几何形状的数学运算模型；第二个职责是在 GUI 上渲染矩形。

对于 SRP 的违反导致了一些严重问题。首先，我们必须在计算几何应用程序中包含进 GUI 代码。在 .NET 中，就必须要把 GUI 组件和计算几何应用一起构建、部署。

其次，如果 GraphicalApplication 的改变由于一些原因导致了 Rectangle 的改变，那么这个改变会迫使我们重新构建、测试以及部署 ComputionalGeometryApplication。如果忘记了这样做，ComputationalGeometryApplication 可能会以不可预测的方式失败。

一个较好的设计是把这两个职责分离到图 8-2 中所示的两个完全不同的类中。这个设计把 Rectangle 类中进行计算的部分移到 GeometricRectangle 类中。现在矩形绘制方式的改变不会对 ComputationalGeometryApplication 造成影响。

### 8.1 定义职责

在 SRP 中，我们把职责定义为变化的原因。如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。有时，我们很难注意到这一点。我们习惯于以组的形式去考虑职责。例如，考虑代码清单 8-1 中的 Modem 接口。大多数人认为这个接口看起来非常合理。该接口所声明的 4 个函数确实是调职解调器所具有的功能。

**代码清单 8-1 Modem.cs — 违反SRP**
```
public interface Modem
{
  public void Dial(String pno);
  public void Hangup();
  public void Send(char c);
  public char Recv();
}
```

然而，该接口中却显示出两个职责。第一个职责是连接管理；第二个职责数据通信。dial 和 hangup 函数进行调职解调器的连接处理，而 send 和 recv 函数进行数据通信。

这两个职责应该分开吗？这依赖于应用程序变化的方式。如果应用程序的变化会影响连接函数的签名，那么这个设计就具有僵化性的臭味，因为调用 send 和 recv 的类必须要重新编译、部署的次数常常会超过我们希望的次数。在这种情况下，这两个职责应该被分离，如图 8-3 中所示。这样做避免了客户应用程序和这两个职责耦合在一起。

另一方面，如果应用程序的变化方式总是导致这两个职责同时变化，那么就不必分离它们。实际上，分离它们就会具有不必要的复杂性的臭味。

在此还有一个推论。仅当变化发生时，变化的轴线才具有实际意义。如果没有征兆，那么应用 SRP 或者任何其他原则都是不明智的。

### 8.2 分离耦合的职责

请注意，在图 8-3 中，我把两个职责都耦合进了 ModemImplementation 类中。这不是所希望的，但是或许是必要的。常常会有一些和硬件或者操作系统的细节有关的原因，迫使我们把不愿耦合在一起的东西耦合在一起。然而，对于应用的其余部分来说，通过分离它们的接口我们已经解耦了概念。

我们可以把 ModemImplementation 类看作是一个杂凑物，或者有缺陷的类。然而，请注意所有的依赖关系都是从它发出的。谁也不需要依赖于它。除了 main 外，谁也不需要知道它的存在。因此，我们已经把丑陋的部分隐藏起来了。其丑陋性不会泄漏出来，污染应用程序的其他部分。

### 8.3 持久化

图 8-4 展示了一种常见的违反 SRP 的情形。Employee 类包含了业务规则和对于持久化的控制。这两个职责在大多数情况下绝不应该混合在一起。业务规则往往会频繁地变化，而持久化的方式却不会如此频繁地变化，并且变化地原因也是完全不同的。把业务规则和持久化子系统绑定在一起的做法是自讨苦吃。

幸运的是，正如我们在第 4 章看到的，测试驱动开发实践常常会远在设计出现臭味之前就迫使我们分离这两个职责。然而，如果测试没有迫使这种分离，而僵化性和脆弱性的臭味又很强烈，那么就应该使用 FACADE（外观）、DAO（数据访问对象）或者 PROXY（代理）模式对设计进行重构，分离这两个职责。

### 8.4 结论

SRP 是所有原则中最简单的原则之一，也是最难正确运用的原则之一。我们会自然地把职责结合在一起。软件设计真正要做的许多工作，就是发现职责并把那些职责相互分离。事实上，我们将要论述的其余原则都会以这样或那样的方式回到这个问题上。

## 第 15 章 状态图

在描述有限状态机（FSM）方面，UML 提供了丰富的符号。在本章中，我们将对其最为有用的部分进行介绍。FSM 对于各种类型软件的编写都是非常有用的工具。在 GUI、通信协议以及任何基于事件系统中，我都是用 FSM。遗憾的是，我发现很多开发者对于 FSM 的概念都不熟悉，因此错失了很多可以简化设计的机会。在本章中，我会尽力改善这种状况。

### 15.1 基础知识

图 15-1 展示了一个简单的状态迁移图（STD），该图描绘了控制用户登录到系统的 FSM。圆角矩形表示状态。上层格间中放置每个状态的名字。下层格间中放置的是一些特定动作，表示当进入或者退出该状态时要做什么。比如，当进入 Prompting for Login 状态时，就会触发 showLoginScreen 动作。当退出该状态时，会触发 hideLoginScreen 动作。

状态之间的箭头线称为迁移。每个迁移上面都标记有该迁移的事件的名字。有些迁移上面还标记有当该迁移被触发时要执行的动作。比如，如果在 Prompting for Login 状态收到 login 事件，就会迁移到 Validateing User 状态并触发 validateUser 动作。

图中左上角的实心圆称为初始伪状态。FSM 从这个伪状态开始，根据变迁规则进行运转。因此，我们的状态机一开始就迁移到 Prompting for Login 状态。

我在 Sending Password Failed 和 Sending Password Succeeded 状态外面画了一个超状态（superstate），因为这两个状态都对 OK 事件作出反应并都迁移到 Prompting for Login 状态。我不想画两个完全一样的箭头线，因此我使用了超状态这个便捷手段。

这个 FSM 非常清楚的表达出了登录过程的工作方式，并把该过程分解成一些易于理解的小函数。如果我们实现了所有这些小函数，如：showLoginScreen、validateUser 以及 sendPassword，并使用图中逻辑把它们编织起来，那么我们就能够确信这个登录过程是可以工作的。

#### 15.1.1 特定事件

状态图标的下层格间含有事件/动作对。entry 和 exit 是标准事件，不过如果需要，你可以提供自己的事件，如图 15-2 所示。当 FSM 在该状态中收到这些特定事件中的某一个时，就会触发对应的动作。

在 UML 出现之前，我习惯于把特定事件表示为一个起止在相同状态上的迁移箭头，如图 15-3 所示。不过，这在 UML 中有些稍微不同的含义。任何导致退出一个状态的迁移都会触发 exit 动作（如果有退出动作的话）。同样，任何导致进入一个状态的迁移都会触发 entry 动作（如果有进入动作的话）。因此，在 UML 中，一个像图 15-3 中所示的自反迁移不仅会触发 myAction，还会触发 exit 和 entry 动作。

#### 15.1.2 超状态

#### 15.1.3 初始伪状态和结束伪状态

图 15-7 展示了两个 UML 中常用的伪状态。FSM 以从初始伪状态迁移出来而开始存在。从初始伪状态的迁移是不能带有事件的，因为这个事件就是状态机的创建。不过，这个迁移可以带有动作。这个动作将作为 FSM 创建完成后触发的第一个动作。

同样，FSM 以迁移到结束伪状态而消亡。这个结束伪状态实际上是永远无法到达的。到结束伪状态的迁移上所带的任何动作都将成为该 FSM 所触发的最后动作。

### 15.2 使用 FSM 图示

我发现像这样的图示在理解那些行为已知子系统的状态机方面非常有用。不过，大部分适合 FSM 的系统，其行为是无法预知的。这些系统的行为会随着时间出现和演化。图示不适合于那些频繁变化的系统。关于布局和间隔方面的问题会损害图示的内容。这种损害有时会阻止设计者对设计做出必须的更改。对于重新格式化图示的恐惧会阻止他们添加一个必须的类或者状态，致使他们采用一种不会影响到图示布局的低劣的解决方案。

另一方面，文本则是一种非常灵活的应对变化的手段。布局根本就不是问题，总是有地方来增加新的文本行。因此，对于那些演化的系统，我会以文本文件的方式创建状态迁移表（STT），而不是 STD。考虑图 15-8 中的地铁旋转门 STD。可以很容易地把它表示成 STT，如表 15-1 所示。

| 当前状态   |   事件  |  新状态    |   动作    |
| :---:     |   :---: | :----:    | :----:    |
| Locked    |   coin  | Unlocked  | Unlock    |
| Locked    |   pass  | Locked    | Alarm     |
| Unlocked  |   coin  | Unlocked  | Refund    |
| Unlocked  |   pass  | Locked    | Lock      |

STT 是一个具有 4 列地简单表格。表的每一行表示一个迁移。对照一下图中的每个迁移箭头线，你会发现表中的行包含了箭头线的两个端点以及相应的事件和动作。你可以使用下面的句子模板来理解 STT：“如果在 Locked 状态，收到 coin 事件，就迁移到 Unlocked 状态并调用 Unlock 函数。”

这个表格可以容易地转换成一个文本文件：

Locked  coin  Unlocked  Unlock

Locked  pass  Locked    Alarm

Unlocked  coin  Unlocked  Refund

Unlocked  pass  Locked  Lock

这 16 个单词包含了 FSM 的所有逻辑。

SMC （状态机编译器）是我们在 1989 年编写的一个简单的编译器，它读进 STT 并产生出实现该逻辑的 C++ 代码。从那时起，SMC 就不断的完善，并可以产生出多种语言的代码。在第 36 章讨论 STATE 模式时，我们会详细研究 SMC。SMC 可以从 www.objectmentor.com 资源区免费获取。

以这种方式创建和维护 FSM 要比维护图示容易得多，并且自动生成代码也节省了大量的时间。因此，虽然图示在帮助你思考或者向他人介绍 FSM 时非常有用，但是对于开发来说，文本格式要方便得多。

### 15.3 结论

有限状态机是一种强大的软件组织思想。UML 在 FSM 可视化方面提供了丰富的符号支持。不过，在开发和维护 FSM 方面，采用文本语言通常要比图形更容易一些。

UML 状态图符号要比我在这里介绍的丰富得多。你还可以应用其他一些伪状态、图标和构件。不过，我很少发现它们是有用的。本章中介绍的就是我曾使用的全部符号。

## 第 17 章 用例

用例是一种非常好的思想，却被极大地过度复杂化了。我总是会看到一些开发团队围坐在一起，讨论用例该如何编写。一般来说，这种团队更多的是在关注形式而非内容。他们在前置条件、后置条件、主参与者、辅助参与者以及一堆根本不重要的事情上争论不休。

使用用例真正的窍门就是保持简单。不要担心用例的格式；简单地把它们写在空白纸、字处理器的空白页或空白的索引卡片上就行了。不要担心需要填写所有的细节。细节只有到了很后期才有用。不必为记录所有的用例而烦恼，那是一项不可能完成的任务。

关于用例，有一点要牢记：**明天，他将会变化。**不管你多么努力地记录它们，不管你在记录细节方面多么地一丝不苟，不管你考虑得多么全面，不管你在研究和分析需求上投入了多少精力：明天，它们将会变化。

如果有些东西明天会变化，那么就不必再今天就记录下它的细节。事实上，你要做的就是把细节的记录推迟到最后一刻。请把用例看作是即时需求。

### 17.1 编写用例

请注意本节的标题。我们是要编写用例，不是画它们。用例不是图示。用例是从一个特定视角进行编写的关于行为需求的文本描述。

“等等！”你喊道，“我知道 UML 中有用例图，我曾经见过。”

不错，UML 中确实有用例图。不过从这些图中你根本看不出任何有关用例的内容。它们根本没有包含任何关于行为需求的信息，而这正是用例该记录的内容。UML 中的用例图记录的完全是其他一些东西。

用例是对系统行为的描述。该描述是从一个让系统完成一些特定工作的用户的视角编写的。用例记录了系统响应单个用户行为所经历的可视事件序列。

可视事件指的是用户能够看得到的事件。用例根本不用描述那些看不见的行为，也不描述那些看不到的系统机制。它们只描述用户能够看得到的东西。

用例通常被分为两部分。第一部分为基本流程（primary course）。在这部分中，我们描述在一切正常的情况下系统是如何响应用户行为的。

例如，下面是销售终端系统的一个典型用例。

**卖出商品**

 * 收银员在扫描器上划过商品，扫描器读取 UPC 码。
 * 商品的价格、描述以及当前价格总数出现在朝向顾客的显示器上。价格和描述也出现在收银员的屏幕上。
 * 价格和描述打印在收条上。
 * 系统发出可以听到的“确认”声音以通知收银员 UPC 码正确读取。

这就是一个用例的基本流程。不需要任何更复杂的东西。事实上，如果用例不是一会儿就要实现，那么即使是上面这几个简单的步骤可能也过于详细了。如果用例不需要在几天或者一周内就要实现，我们是不想记录这种细节的。

如果没有记录下用例的细节，如何才能对它进行估算呢？你可以去询问利益相关者有关细节的内容，不必把它记录下来。这会为你提供进行粗略估算所需要的信息。既然要去询问利益相关者一些细节方面的内容，为什么不把它们记录下来呢？因为明天，细节将会变化。难道变化不会影响到估算吗？会影响的，不过对于大量的用例来说，这些影响会相互抵消。过早地记录下细节是完全不划算的。

如果我们现在不去记录用例的细节，那记录什么呢？如果不写下一些东西，我们又如何知道存在用例呢？记下用例的名字即可。在电子表格或者字处理器文档中保持用例名字的代码清单。更好的做法是，把用例的名字写在索引卡片上，并维持一个用例卡片栈。当接近实现时填入细节。

#### 17.1.1 备选流程

有些细节关注的是那些出错的情况。在和利益相关者交谈期间，你会希望谈论一些出问题的场景。之后，随着越来越接近用例的实现时间，你会越来越多地考虑这些备选流程。备选流程是用例基本流程地补充。它们可以按照如下方式编写。

**无法读取 UPC 码**

如果扫描器无法读取 UPC 码，系统应该发出“重新扫描”声音，以通知收银员再试一次。如果重试三次仍然失败，那么收银员应该手工输入 UPC 码。

**没有 UPC 码**

如果商品上没有 UPC 码，那么收银员应该手工输入价格。

这些备选流程非常有趣，因为它们提供了存在其他用例的线索，而这些用例可能是利益相关者一开始没有识别出来的。在本例中，能够手工输入 UPC 或者价格显然是必要的。

#### 17.1.2 其他东西呢

参与者、辅助参与者、前置条件、后置条件以及其他东西是怎么回事呢？不必担心所有这些东西。对于你将从事的绝大多数系统而言，都不必知道这些内容。当需要了解更多的用例知识时，你可以阅读 Alistair Cockburn 关于这个主题的权威著作。现在，在学跑之前先学会走吧。请先掌握简单用例的编写。当你精通这些之后（也就是已经成功地在项目中使用了），才可以非常小心、克制地采用一些更为复杂地技术。但是，一定要记住，不要坐下来想象。

### 17.2 结论

本章很短。这是合适的，因为本章的主题本身比较简单。你对用例的态度一定要保持这种简单性。如果你陷入了用例复杂性的黑暗面，它就会永远控制你的命运。请尽量保持用例简单。

# 第 Ⅲ 部分 薪水支付案例研究

# 第 Ⅳ 部分 打包薪水支付系统

# 第 Ⅴ 部分 气象站案例研究

# 第 Ⅵ 部分 ETS 案例研究
