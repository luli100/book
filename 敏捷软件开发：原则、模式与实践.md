- [第Ⅰ部分 敏捷开发](#第ⅰ部分-敏捷开发)
  - [第 1 章 敏捷实践](#第-1-章-敏捷实践)
  - [第 2 章 极限编程概述](#第-2-章-极限编程概述)
    - [2.1 极限编程实践](#21-极限编程实践)
      - [2.1.1 客户作为团队成员](#211-客户作为团队成员)
  - [第 3 章 计划](#第-3-章-计划)
    - [3.1 初始探索](#31-初始探索)
  - [第 4 章 测试](#第-4-章-测试)
  - [第 5 章 重构](#第-5-章-重构)
    - [5.1 素数产生程序：一个简单的重构示例](#51-素数产生程序一个简单的重构示例)
  - [第 6 章 一次编程实践](#第-6-章-一次编程实践)
- [第Ⅱ部分 敏捷设计](#第ⅱ部分-敏捷设计)
  - [第 8 章 单一职责原则（SRP）](#第-8-章-单一职责原则srp)
    - [8.1 单一职责原则](#81-单一职责原则)
- [第 Ⅲ 部分 薪水支付案例研究](#第-ⅲ-部分-薪水支付案例研究)
- [第 Ⅳ 部分 打包薪水支付系统](#第-ⅳ-部分-打包薪水支付系统)
- [第 Ⅴ 部分 气象站案例研究](#第-ⅴ-部分-气象站案例研究)
- [第 Ⅵ 部分 ETS 案例研究](#第-ⅵ-部分-ets-案例研究)

# 第Ⅰ部分 敏捷开发

## 第 1 章 敏捷实践

## 第 2 章 极限编程概述

**作为开发人员，我们应该记住，XP 并非惟一选择**

在上一章中，我们简要介绍了有关敏捷软件开发方法方面的内容，但它没有确切地告诉我们去做些什么；其中给出了一些泛泛地陈述和目标，却没有给出实际的直到方法。本章要改变这种状况。

### 2.1 极限编程实践

极限编程（eXtreme Programming，简称 XP）是敏捷方法中最著名的一个。它由一系列简单却相互依赖的实践组成。这些实践结合在一起形成了一个胜于部分结合的整体。本章我们将简要地探讨一下这个整体，在后续地章节中，会对一些单独地实践进行研究。

#### 2.1.1 客户作为团队成员

我们希望客户和开发人员在一起紧密地工作，以便于彼此知晓对方所面临地问题，并共同去解决这些问题。

谁是客户？XP 团队中的客户是指定义产品的特性并排列这些特性优先级的人或团体。有时，客户是和开发人员同属一家公司的一组业务分析师或者市场专家。有时，客户是用户团体委派的用户代表。有时，客户事实上是支付开发费用的人。但是在 XP 项目中，无论谁是客户，他们都是能够和团队一起工作的团队成员。

最好的情况是客户和开发人员在同一个房间中工作，次一点的情况是客户和开发人员之间的工作距离在 100 米以内。距离越大，客户就约难成为真正的团队成员。如果客户工作在另外一幢建筑或另外一个州，那么他将很难融合到团队中来。

如果确实无法和客户在一起工作，该怎么办呢？我的建议是去寻找能够在一起工作、愿意并能够代替真正客户的人。

## 第 3 章 计划

**当你能够度量你所说的，并且能够用数字去表达它时，就表示你了解了它；若你不能度量它，不能用数字去表达它，那么说明你的知识就是匮乏的、不能令人满意的。**

下面的内容是对极限编程（XP）中计划游戏（planning game）部分的描述。它和在其他敏捷方法（如 SCRUM、Crystal、Feature-Driven Development，简称 FDD、Adaptive Software Development，简称 ADP）中做计划的方式相似。不过，那些过程方法都没有极限编程对此描述得详细、精确。

### 3.1 初始探索

在项目开始时，开发人员和客户会尽量确定出所有真正的用户故事。然而，他们不会试图去确定所有的用户故事。随着项目的进展，客户会不断编写新的用户故事。素材的编写会一直持续到项目完成。

开发人员共同对这些素材进行估算。估算是相对的，不是绝对的。我们在记录素材的卡片上写上一点“点数”来表示实现这个素材所需要的相对时间。我们可能不能确定一个“点”代表多少时间，但是我们知道实现 8 个点的素材所需要的时间是实现 4 个点的两倍。

**探究、分解和速度**

过大或者多小的素材都是难以估算的。开发人员往往会低估哪些大大的素材而高估那些小的素材。任何过大的素材都应该被分解成小一点的部分，任何过小素材都应该和其他小的素材合并。

例如，考虑下面这个用户素材：“用户能够安全地进行存款、取款、转账活动。”

## 第 4 章 测试

## 第 5 章 重构

**大千世界中，惟一缺乏的就是人类的注意力。**

本章讲述的是关于人的注意力的。阐述人们应该专注于手边的工作并且确信自己正在尽全力，说明了使事物能够工作和使事物正确之间的区别，介绍了我们放入代码结构中的价值。

在 Martin Fowler 的名著《重构》一书中，他把重构（Refactoring）定义为：“...在不改变代码外在行为的前提下对代码做出修改，以改进代码的内部结构的过程。”可是我们为什么要改进已经能够工作的代码的结构呢？不是还有句古老的谚语，“如果它没有坏，就不要去修理它！”吗？

每一个软件模块都具有三项职责。第一个职责是它运行起来所完成的功能。这也是该模块得以存在的原因。第二个职责是它要应对变化。几乎所有的模块在它们的生命周期中都要变化，开发者有责任保证这种改变应该尽可能地简单。一个难以改变的模块是拙劣的，即使能够工作，也需要对它进行修正。第三个职责是要阅读它的人能够理解。对该模块不熟悉的开发人员应该能够比较容易地阅读并理解它。一个无法被理解的模块也是拙劣的，同样需要对它进行修正。

怎样才能让软件模块易于阅读、易于修改呢？本书的主要内容都是关于一些原则和模式的，使用这些原则和模式可以帮助你创建更加灵活和具有适应性的软件模块。然而，要使软件模块易于阅读和修改，所需要的不仅仅是一些原则和模式。还需要你的注意力，需要纪律约束，需要创造美的激情。

### 5.1 素数产生程序：一个简单的重构示例

观察程序 5.1 中所示的代码，这个程序会产生素数。它是一个大函数，其中有辅助阅读的注释和很多单字母变量。

**程序 5-1 GeneratePrimes.cs，版本 1**
```
using System;
public class GeneratePrimes
{
  public static int[] GeneratePrimeNumbers(int maxValue)
  {
    if (maxValue >= 2)
    {
      int s = maxValue + 1;
      bool[] f = new bool[s];
      int i;
      
      for (i = 0; i < s; i++)
      {
        f[i] = true;
      }
      
      f[0] = f[1] = false;
      int j;
      for (i = 2; i < Math.Sqrt(s) + 1; i++)
      {
        if(f[i])
        {
          for (j = 2 * i; j < s; j += i)
          f[j] = false;
        }
      }
      
      int count = 0;
      for (i = 0; i < s; i++)
      {
        if (f[i])
        {
          count++;
        }
      }

      int[] primes = new int[count];
      for (i = 0, j = 0; i < s; i++)
      {
        if (f[i])
        {
          primes[j++] = i;
        }
      }
      return primes;
    }
    else
    {
      return new int[0];
    }
  }
}
```

为 GeneratePrimes 编写的单元测试可以参见程序 5.2。它采用了一种统计学的方法，主要检查产生器能否产生 0、2、3 以及 100 以内的素数。在第一种情况下，应该没有素数；在第二种情况下，应该有一个素数，并且该素数应该是 2；在第三种情况下，应该有两个素数，它们应该是 2 和 3。在最后一种情况下，应该有 25 个素数，其中最后一个是 97。如果所有这些测试都通过了，那么就认为产生器是可以工作的。我怀疑这种做法的可靠性，但是我不能想象出一个合理的情况，在这个情况下这些测试都将通过但是函数却是错误的。

**程序 5.2 GeneratePrimesTest.cs**
```
using NUnit.Framework;
[TestFixture]
public class GeneratePrimesTest
{
  [Test]
  public void TestPrimes()
  {
    int[] nullArray = GeneratePrimes.GeneratePrimeNumbers(0);
    Assert.AreEqual(nullArray.Length, 0);
    int[] minArray = GeneratePrimes.GeneratePrimeNumbers(2);
    Assert.AreEqual(minArray.Length, 1);
    Assert.AreEqual(minArray[0], 2);
    int[] threeArray = GeneratePrimes.GeneratePrimeNumbers(3);
    Assert.AreEqual(threeArray.Length, 2);
    Assert.AreEqual(threeArray[0], 2);
    Assert.AreEqual(threeArray[1], 3);
    int[] centArray = GeneratePrimes.GeneratePrimeNumbers(100);
    Assert.AreEqual(centArray.Length, 25);
    Assert.AreEqual(centArray[24], 97);
  }
}
```

## 第 6 章 一次编程实践

# 第Ⅱ部分 敏捷设计

## 第 8 章 单一职责原则（SRP）

**只有佛自己应当担负起公布玄妙秘密的职责。**

单一职责原则曾经在 Tom Demaro 和 Meilir Page-Jones 的著作中描述过，并称之为内聚性。他们把内聚性定义为：一个模块的组成元素之间的功能相关性。在本文章中，我们稍微改变一下它的含义，把内聚性和引起一个模块或者类改变的作用力联系起来。

### 8.1 单一职责原则

就一个类而言，应该仅有一个引起它变化的原因

考虑第 6 章中保龄球比赛的例子。在开发它的大部分时间内，Game 类一直具有两个不同的职责。一个职责是跟踪当前轮的比赛，另一个职责是计算比赛的得分。最后，RCM和RSK把这两个职责分离到两个类中。Game类保持跟踪每一轮比赛的职责，Scorer类负责计算比赛的得分。

为何要把这两个职责分离到单独的类中呢？因为每一个职责都是一个变化轴线。当需要变化时，该变化会反映为类的职责变化。如果一个类承担了多于一个职责，那么引起它变化的原因就会有多个。

如果一个类承担的职责过多，就等于把这些职责耦合在了一起。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。

例如，考虑图 1 中的设计。Rectangle 类具有两个方法，如果所示。一个方法把矩形绘制在屏幕上，另一个方法计算矩形的面积。

有两个不同的应用程序使用 Rectangle 类。一个应用程序是有关计算几何学方面的，使用 Rectangle 类来处理几何形状的数据运算，但它从来不会在屏幕上绘制矩形。另一个应用程序实质上有关图形绘制方面的，它也可能会进行一些几何运算，但它可能会在屏幕上绘制矩形。

这个设计违反了单一职责原则。Rectangle 类具有两个职责。第一个职责提供了一个矩形几何形状的数学运算模型；第二个职责是在 GUI 上渲染矩形。

对于SRP的违反导致了一些严重问题。首先，我们必须在计算几何应用程序中包含进 GUI 代码。如果

# 第 Ⅲ 部分 薪水支付案例研究

# 第 Ⅳ 部分 打包薪水支付系统

# 第 Ⅴ 部分 气象站案例研究

# 第 Ⅵ 部分 ETS 案例研究
